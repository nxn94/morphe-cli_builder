name: Build Morphe‑patched apps

on:
  workflow_dispatch:
  schedule:
    - cron: "15 5 * * *" # daily at 05:15 UTC

permissions:
  contents: write
  actions: read

jobs:
  check-versions:
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.version-check.outputs.should-build }}
      patches-version: ${{ steps.version-check.outputs.patches-version }}
      cli-version: ${{ steps.version-check.outputs.cli-version }}
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check latest versions
        id: version-check
        run: |
          set -euo pipefail
          
          # Get latest versions
          PATCHES_TAG="$(gh release view --repo MorpheApp/morphe-patches --json tagName -q .tagName)"
          CLI_TAG="$(gh release view --repo MorpheApp/morphe-cli --json tagName -q .tagName)"
          
          echo "patches-version=$PATCHES_TAG" >> "$GITHUB_OUTPUT"
          echo "cli-version=$CLI_TAG" >> "$GITHUB_OUTPUT"
          
          # Load previous state
          if [ -f state.json ]; then
            PREV_PATCHES=$(jq -r '.patches_version // "none"' state.json)
            PREV_CLI=$(jq -r '.cli_version // "none"' state.json)
          else
            PREV_PATCHES="none"
            PREV_CLI="none"
          fi
          
          # Check if versions changed
          if [ "$PATCHES_TAG" != "$PREV_PATCHES" ] || [ "$CLI_TAG" != "$PREV_CLI" ]; then
            echo "should-build=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Version changes detected. Patches: $PREV_PATCHES → $PATCHES_TAG, CLI: $PREV_CLI → $CLI_TAG"
          else
            echo "should-build=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No version changes detected. Skipping build."
          fi

  build:
    needs: check-versions
    if: needs.check-versions.outputs.should-build == 'true'
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: youtube
            appId: com.google.android.youtube
          - name: ytmusic
            appId: com.google.android.apps.youtube.music
          - name: reddit
            appId: com.reddit.frontpage

    env:
      # Where we'll put tools/artifacts
      GH_TOKEN: ${{ github.token }}
      TOOLS_DIR: tools
      APKS_DIR: apps
      OUT_DIR: out
      APKEEP_CACHE_VERSION: "1"
      PATCHES_VERSION: ${{ needs.check-versions.outputs.patches-version }}
      CLI_VERSION: ${{ needs.check-versions.outputs.cli-version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java (for morphe-cli)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17" # any current LTS JRE is fine to run the CLI [9](https://aur.archlinux.org/packages/morphe-cli)

      - name: Restore Rust/apkeep cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
            ~/.rustup/toolchains
            ~/.rustup/update-hashes
          key: ${{ runner.os }}-apkeep-${{ env.APKEEP_CACHE_VERSION }}

      - name: Install jq & apkeep (cached)
        run: |
          set -euo pipefail
          
          echo "::notice::Installing dependencies..."
          sudo apt-get update -y
          sudo apt-get install -y jq curl unzip libbcprov-java

          # Ensure Cargo bin path is available for current and subsequent steps.
          export PATH="$HOME/.cargo/bin:$PATH"
          echo "$HOME/.cargo/bin" >> "$GITHUB_PATH"

          # Install Rust only when missing.
          if ! command -v cargo &> /dev/null; then
            echo "::notice::Installing Rust toolchain..."
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
          fi
          if [ -f "$HOME/.cargo/env" ]; then
            source "$HOME/.cargo/env"
          fi

          # Build apkeep only when cache does not already provide it.
          if command -v apkeep &> /dev/null; then
            echo "::notice::Using cached apkeep binary"
          else
            echo "::notice::Building and installing apkeep from source..."
            cargo install apkeep --locked --quiet
          fi
          
          # Verify installation
          if ! command -v apkeep &> /dev/null; then
            echo "::error::apkeep installation failed"
            exit 1
          fi
          
          echo "::notice::apkeep installed successfully"
          apkeep --version

      - name: Prepare dirs
        run: |
          mkdir -p "$TOOLS_DIR" "$APKS_DIR" "$OUT_DIR"

      - name: Get latest Morphe patches + CLI
        id: morphe
        run: |
          set -euo pipefail

          # Reuse versions already resolved in check-versions job.
          PATCHES_TAG="${PATCHES_VERSION}"
          CLI_TAG="${CLI_VERSION}"
          if [ -z "$PATCHES_TAG" ] || [ -z "$CLI_TAG" ]; then
            echo "::error::Missing release version(s). patches='$PATCHES_TAG' cli='$CLI_TAG'"
            exit 1
          fi

          echo "patches_tag=$PATCHES_TAG" >> "$GITHUB_OUTPUT"
          gh release download "$PATCHES_TAG" \
            --repo MorpheApp/morphe-patches \
            --pattern 'patches-*.mpp' \
            --dir "$TOOLS_DIR" >/dev/null
          # also fetch patches-list.json to know available patches by app [3](https://github.com/MorpheApp/morphe-patches)
          curl -fsSL "https://raw.githubusercontent.com/MorpheApp/morphe-patches/${PATCHES_TAG}/patches-list.json" \
            -o "$TOOLS_DIR/patches-list.json"

          echo "cli_tag=$CLI_TAG" >> "$GITHUB_OUTPUT"
          gh release download "$CLI_TAG" \
            --repo MorpheApp/morphe-cli \
            --pattern 'morphe-cli-*-all.jar' \
            --dir "$TOOLS_DIR" >/dev/null

      - name: Sync patches.json with latest patches (preserve edits)
        run: |
          set -euo pipefail

          DEFAULTS_FILE="$RUNNER_TEMP/default_patches.json"
          EXISTING_FILE="$RUNNER_TEMP/existing_patches.json"
          PKGS='["com.google.android.youtube","com.google.android.apps.youtube.music","com.reddit.frontpage"]'

          # Build defaults for all known apps from the latest patches list.
          jq --argjson pkgs "$PKGS" '
            def patch_list: (.patches // .);
            def is_compatible($patch; $pkg):
              if ($patch.compatiblePackages? | type) == "object" then
                (($patch.compatiblePackages[$pkg]? | type) == "array")
              elif ($patch.compatible_packages? | type) == "object" then
                (($patch.compatible_packages[$pkg]? | type) == "array")
              else
                (($patch.compatiblePackages // $patch.compatible_packages // [])
                  | if type == "array" then any((.name // .packageName // "") == $pkg) else false end)
              end;

            reduce $pkgs[] as $pkg ({};
              .[$pkg] = (
                (patch_list
                  | map(select(is_compatible(.; $pkg)))
                  | map({(.name): true})
                  | add
                ) // {}
              )
            )
          ' "$TOOLS_DIR/patches-list.json" > "$DEFAULTS_FILE"

          # Load existing user config if valid JSON, otherwise start fresh.
          if [ -f patches.json ] && jq empty patches.json >/dev/null 2>&1; then
            cp patches.json "$EXISTING_FILE"
          else
            if [ -f patches.json ]; then
              echo "::warning::Existing patches.json is invalid JSON; regenerating from defaults."
            fi
            echo '{}' > "$EXISTING_FILE"
          fi

          # Merge defaults with existing file, preserving user-edited values.
          jq -n --slurpfile defaults "$DEFAULTS_FILE" --slurpfile existing "$EXISTING_FILE" '
            ($defaults[0] // {}) as $d
            | ($existing[0] // {}) as $e
            | ($e | if type == "object" then . else {} end) as $base
            | reduce ($d | keys[]) as $pkg ($base;
                .[$pkg] = (
                  ($d[$pkg] // {})
                  * ((.[$pkg] // {}) | if type == "object" then . else {} end)
                )
              )
          ' > patches.json.tmp
          mv patches.json.tmp patches.json

          echo "::notice::Synced patches.json with latest available patches while preserving existing edits."
          jq 'keys' patches.json

      - name: Resolve supported version for ${{ matrix.appId }}
        id: targetver
        run: |
          set -euo pipefail

          DISABLED_PATCHES_JSON="$(jq -c --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries | map(select(.value == false) | .key)' patches.json)"

          STRICT_VERSIONS="$(
            jq -r \
              --arg pkg "${{ matrix.appId }}" \
              --argjson disabled "$DISABLED_PATCHES_JSON" \
              '
              (.patches // .)
              | map(
                  select(
                    ((.use // true) == true)
                    and ((.name as $n | ($disabled | index($n)) | not))
                    and ((.compatiblePackages[$pkg]? | type) == "array")
                  )
                )
              | map(.compatiblePackages[$pkg]) as $version_lists
              | if ($version_lists | length) == 0 then
                  empty
                else
                  reduce $version_lists[] as $current ($version_lists[0];
                    map(select($current | index(.)))
                  )[]
                end
              ' "$TOOLS_DIR/patches-list.json" || true
          )"

          VERSION_COUNTS="$(
            jq -r \
              --arg pkg "${{ matrix.appId }}" \
              --argjson disabled "$DISABLED_PATCHES_JSON" \
              '
              (.patches // .) as $patches
              | $patches
              | map(
                  select(
                    ((.use // true) == true)
                    and ((.name as $n | ($disabled | index($n)) | not))
                    and ((.compatiblePackages[$pkg]? | type) == "array")
                  )
                )
              | map(.compatiblePackages[$pkg][])
              | sort
              | group_by(.)
              | map([length, .[0]])
              | .[]
              | @tsv
              ' "$TOOLS_DIR/patches-list.json" || true
          )"

          TARGET_VERSION=""
          TARGET_VERSIONS=""
          if [ -n "$STRICT_VERSIONS" ]; then
            TARGET_VERSIONS="$(printf '%s\n' "$STRICT_VERSIONS" | sort -Vr | paste -sd, -)"
            TARGET_VERSION="$(printf '%s\n' "$STRICT_VERSIONS" | sort -Vr | head -n1)"
          elif [ -n "$VERSION_COUNTS" ]; then
            TARGET_VERSIONS="$(printf '%s\n' "$VERSION_COUNTS" | sort -t $'\t' -k1,1nr -k2,2Vr | cut -f2 | paste -sd, -)"
            TARGET_VERSION="$(printf '%s\n' "$VERSION_COUNTS" | sort -t $'\t' -k1,1nr -k2,2Vr | head -n1 | cut -f2)"
          fi

          if [ -n "$TARGET_VERSION" ]; then
            echo "version=$TARGET_VERSION" >> "$GITHUB_OUTPUT"
            echo "versions=$TARGET_VERSIONS" >> "$GITHUB_OUTPUT"
            echo "::notice::Selected most compatible version for ${{ matrix.appId }}: $TARGET_VERSION"
          else
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "versions=" >> "$GITHUB_OUTPUT"
            echo "::warning::Could not resolve a supported version from patches list; falling back to latest available download."
          fi

      - name: Download supported APK for ${{ matrix.appId }}
        id: getapk
        run: |
          set -euo pipefail
          
          echo "::notice::Downloading APK for ${{ matrix.appId }}..."
          TARGET_VERSION="${{ steps.targetver.outputs.version }}"
          TARGET_VERSIONS="${{ steps.targetver.outputs.versions }}"
          
          # Create output directory if it doesn't exist
          mkdir -p "$APKS_DIR"
          rm -f "$APKS_DIR"/* || true
          : > apkeep.log
          
          find_package_candidate() {
            find "$APKS_DIR" -type f \
              \( -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" \) \
              -printf '%p\n' \
              | awk '
                  function lower(s){ return tolower(s) }
                  function score(path, n, ext, s) {
                    n = lower(path)
                    ext = n
                    sub(/^.*\./, "", ext)
                    s = 0
                    if (ext == "apk") s += 2000
                    else if (ext == "xapk" || ext == "apkm") s += 500
                    if (n ~ /\/base\.apk$/) s += 500
                    if (n ~ /arm64-v8a|arm64_v8a|arm64/) s += 800
                    if (n ~ /nodpi/) s += 400
                    if (n ~ /x86_64|x86/) s -= 600
                    if (n ~ /armeabi-v7a|arm-v7a|v7a/) s -= 300
                    if (n ~ /split_config|(^|\/)config\./) s -= 1400
                    return s
                  }
                  {
                    s = score($0)
                    if (best == "" || s > bests) {
                      best = $0
                      bests = s
                    }
                  }
                  END { if (best != "") print best }
                ' || true
          }

          apk_has_dex() {
            local apk="$1"
            unzip -Z1 "$apk" 2>/dev/null | grep -Eq '^classes([0-9]+)?\.dex$'
          }

          download_with_apkeep() {
            local version="$1"
            local -a args=(-a "${{ matrix.appId }}" -d apk-pure "$APKS_DIR")
            if [ -n "$version" ]; then
              args+=(--version "$version")
            fi
            apkeep "${args[@]}" 2>&1 | tee -a apkeep.log
          }

          APK_CANDIDATE=""
          RESOLVED_DOWNLOAD_VERSION=""

          if [ -n "$TARGET_VERSIONS" ]; then
            IFS=',' read -r -a VERSION_LIST <<< "$TARGET_VERSIONS"
            for v in "${VERSION_LIST[@]}"; do
              [ -z "$v" ] && continue
              echo "::notice::Trying supported version $v for ${{ matrix.appId }}..."
              if download_with_apkeep "$v"; then
                echo "::notice::apkeep completed for version $v"
              else
                echo "::warning::apkeep failed for version $v"
              fi

              APK_CANDIDATE="$(find_package_candidate)"
              if [ -n "$APK_CANDIDATE" ] && [ -f "$APK_CANDIDATE" ]; then
                RESOLVED_DOWNLOAD_VERSION="$v"
                break
              fi
            done
          fi

          if [ -z "$APK_CANDIDATE" ]; then
            echo "::notice::No package downloaded from supported-version attempts. Retrying source default package selection."
            if download_with_apkeep ""; then
              echo "::notice::apkeep completed for latest available package"
            else
              echo "::warning::apkeep failed for latest available package"
            fi
            APK_CANDIDATE="$(find_package_candidate)"
          fi

          if [ -n "$APK_CANDIDATE" ] && [ -f "$APK_CANDIDATE" ]; then
            echo "::notice::Found package in $APKS_DIR: $APK_CANDIDATE"
          else
            # Fallback: check current directory and move into APKS_DIR.
            APK_FOUND="$(find . -maxdepth 1 -type f \( -name "*${{ matrix.appId }}*.apk" -o -name "*${{ matrix.appId }}*.xapk" -o -name "*${{ matrix.appId }}*.apkm" -o -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" \) | head -n1 || true)"
            if [ -n "$APK_FOUND" ] && [ -f "$APK_FOUND" ]; then
              echo "::notice::Found package in current dir: $APK_FOUND"
              mv "$APK_FOUND" "$APKS_DIR/"
              APK_CANDIDATE="$APKS_DIR/$(basename "$APK_FOUND")"
            else
              echo "::error::No APK found after download"
              echo "::notice::Files in current directory:"
              ls -la
              echo "::notice::Files in $APKS_DIR:"
              ls -la "$APKS_DIR" || true
              echo "::notice::apkeep log:"
              cat apkeep.log || true
              exit 1
            fi
          fi

          # If an APK was selected directly, ensure it contains dex classes and is not a split-only config APK.
          if [[ "$APK_CANDIDATE" == *.apk ]] && ! apk_has_dex "$APK_CANDIDATE"; then
            echo "::warning::Selected APK does not contain classes.dex; trying another APK candidate."
            ALT_APK="$(
              find "$APKS_DIR" -type f -name "*.apk" -printf '%p\n' \
                | awk '
                    function lower(s){ return tolower(s) }
                    function score(path, n, s) {
                      n = lower(path)
                      s = 2000
                      if (n ~ /\/base\.apk$/) s += 500
                      if (n ~ /arm64-v8a|arm64_v8a|arm64/) s += 800
                      if (n ~ /nodpi/) s += 400
                      if (n ~ /x86_64|x86/) s -= 600
                      if (n ~ /armeabi-v7a|arm-v7a|v7a/) s -= 300
                      if (n ~ /split_config|(^|\/)config\./) s -= 1400
                      return s
                    }
                    { print score($0), $0 }
                  ' | sort -nr | cut -d' ' -f2-
            )"
            while IFS= read -r candidate; do
              [ -z "$candidate" ] && continue
              if apk_has_dex "$candidate"; then
                APK_CANDIDATE="$candidate"
                echo "::notice::Using APK with dex content: $APK_CANDIDATE"
                break
              fi
            done <<< "$ALT_APK"
          fi

          # If downloader produced split package (.xapk/.apkm), extract an installable APK.
          APK_PATH="$APK_CANDIDATE"
          case "$APK_CANDIDATE" in
            *.xapk|*.apkm)
              echo "::notice::Split package detected ($APK_CANDIDATE); extracting APK..."
              XAPK_TMP="$RUNNER_TEMP/xapk_${{ matrix.name }}"
              rm -rf "$XAPK_TMP"
              mkdir -p "$XAPK_TMP"
              unzip -o -q "$APK_CANDIDATE" '*.apk' -d "$XAPK_TMP" || true

              # Prefer arm64-v8a + nodpi APK names. Avoid split config files when possible.
              EXTRACTED_APK="$(
                find "$XAPK_TMP" -type f -name "*.apk" -printf '%p\n' \
                  | awk '
                      function lower(s){ return tolower(s) }
                      function score(path, n, b, s) {
                        n = lower(path)
                        b = n
                        sub(/^.*\//, "", b)
                        s = 0
                        if (b == "base.apk") s += 500
                        if (n ~ /arm64-v8a|arm64_v8a|arm64/) s += 800
                        if (n ~ /nodpi/) s += 400
                        if (n ~ /x86_64|x86/) s -= 600
                        if (n ~ /armeabi-v7a|arm-v7a|v7a/) s -= 300
                        if (n ~ /split_config/) s -= 1200
                        return s
                      }
                      {
                        s = score($0)
                        if (best == "" || s > bests) {
                          best = $0
                          bests = s
                        }
                      }
                      END { if (best != "") print best }
                    '
              )"
              if [ -z "$EXTRACTED_APK" ]; then
                # Last fallback: largest APK in archive.
                EXTRACTED_APK="$(find "$XAPK_TMP" -type f -name "*.apk" -printf '%s %p\n' | sort -nr | head -n1 | cut -d' ' -f2- || true)"
              fi

              if [ -z "$EXTRACTED_APK" ] || [ ! -f "$EXTRACTED_APK" ]; then
                echo "::error::Could not extract APK from split package: $APK_CANDIDATE"
                echo "::notice::Archive APK contents:"
                find "$XAPK_TMP" -type f -name "*.apk" -print || true
                exit 1
              fi

              APK_PATH="$APKS_DIR/${{ matrix.appId }}.apk"
              cp "$EXTRACTED_APK" "$APK_PATH"
              echo "::notice::Extracted APK: $APK_PATH (from $(basename "$EXTRACTED_APK"))"
              ;;
          esac

          if [ ! -f "$APK_PATH" ]; then
            echo "::error::APK path check failed: $APK_PATH"
            exit 1
          fi

          if ! apk_has_dex "$APK_PATH"; then
            echo "::error::Chosen APK has no classes.dex and cannot be patched: $APK_PATH"
            echo "::notice::Files in $APKS_DIR:"
            find "$APKS_DIR" -type f \( -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" \) -print || true
            exit 1
          fi
          
          echo "apk=$APK_PATH" >> "$GITHUB_OUTPUT"
          
          # Extract version from APK filename
          APK_FILENAME=$(basename "$APK_PATH")
          APK_VERSION=$(echo "$APK_FILENAME" | grep -oE '[0-9]+(\.[0-9]+){2,}' | head -1 || true)
          if [ -z "$APK_VERSION" ] && [ -n "$RESOLVED_DOWNLOAD_VERSION" ]; then
            APK_VERSION="$RESOLVED_DOWNLOAD_VERSION"
          fi
          if [ -z "$APK_VERSION" ] && [ -n "$TARGET_VERSION" ]; then
            APK_VERSION="$TARGET_VERSION"
          fi
          if [ -z "$APK_VERSION" ]; then
            APK_VERSION="unknown"
          fi
          echo "version=$APK_VERSION" >> "$GITHUB_OUTPUT"
          echo "::notice::Downloaded ${{ matrix.name }} → $APK_PATH (v$APK_VERSION)"

      - name: Prepare signing keystore (required)
        id: keystore
        run: |
          set -euo pipefail

          KEYSTORE_B64="${{ secrets.KEYSTORE_BASE64 }}"
          KEYSTORE_PASSWORD="${{ secrets.KEYSTORE_PASSWORD }}"
          KEY_PASSWORD_RAW="${{ secrets.KEY_PASSWORD }}"
          KEY_ALIAS_INPUT="${{ secrets.KEY_ALIAS }}"

          if [ -z "$KEYSTORE_B64" ]; then
            echo "::error::KEYSTORE_BASE64 secret is required (signed builds are enforced)."
            exit 1
          fi
          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "::error::KEYSTORE_PASSWORD secret is required (signed builds are enforced)."
            exit 1
          fi
          BCPROV_JAR="$(ls -1 /usr/share/java/bcprov*.jar 2>/dev/null | head -n1 || true)"
          if [ -z "$BCPROV_JAR" ] || [ ! -f "$BCPROV_JAR" ]; then
            echo "::error::BouncyCastle provider JAR not found on runner."
            exit 1
          fi

          RAW_KEYSTORE="$TOOLS_DIR/source.keystore"
          DEST_KEYSTORE="$TOOLS_DIR/morphe.bks"
          rm -f "$RAW_KEYSTORE" "$DEST_KEYSTORE"

          echo "$KEYSTORE_B64" | base64 -d > "$RAW_KEYSTORE"

          detect_keystore_type() {
            local type="$1"
            local -a args=(keytool -list -keystore "$RAW_KEYSTORE" -storetype "$type" -storepass "$KEYSTORE_PASSWORD")
            if [ "$type" = "BKS" ] || [ "$type" = "UBER" ]; then
              args+=(-providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath "$BCPROV_JAR")
            fi
            "${args[@]}" >/dev/null 2>&1
          }

          SRC_TYPE=""
          for t in PKCS12 JKS BKS UBER; do
            if detect_keystore_type "$t"; then
              SRC_TYPE="$t"
              break
            fi
          done

          if [ -z "$SRC_TYPE" ]; then
            echo "::error::Could not detect source keystore type using PKCS12/JKS/BKS/UBER."
            exit 1
          fi
          echo "::notice::Detected source keystore type: $SRC_TYPE"

          IMPORT_LOG="$RUNNER_TEMP/keytool_import_${{ matrix.name }}.log"
          run_import() {
            local mode="$1"
            shift
            echo "::notice::Converting keystore to BKS (mode=$mode)..."
            set +e
            "$@" >"$IMPORT_LOG" 2>&1
            local rc=$?
            set -e
            if [ "$rc" -ne 0 ]; then
              echo "::warning::keytool import failed in mode=$mode"
              cat "$IMPORT_LOG" || true
            fi
            return "$rc"
          }

          IMPORT_BASE_ARGS=(
            keytool -importkeystore -noprompt
            -srckeystore "$RAW_KEYSTORE"
            -srcstoretype "$SRC_TYPE"
            -srcstorepass "$KEYSTORE_PASSWORD"
            -destkeystore "$DEST_KEYSTORE"
            -deststoretype BKS
            -deststorepass "$KEYSTORE_PASSWORD"
            -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider
            -providerpath "$BCPROV_JAR"
          )

          # Try import without explicit key password first. This works for the common case where
          # key password matches store password and avoids false failures from wrong KEY_PASSWORD.
          if ! run_import "no-keypass" "${IMPORT_BASE_ARGS[@]}"; then
            # Retry with explicit key password if provided.
            if [ -n "$KEY_PASSWORD_RAW" ]; then
              rm -f "$DEST_KEYSTORE"
              if ! run_import "explicit-keypass" "${IMPORT_BASE_ARGS[@]}" -srckeypass "$KEY_PASSWORD_RAW" -destkeypass "$KEY_PASSWORD_RAW"; then
                echo "::error::Failed to convert keystore to BKS."
                echo "::error::Check KEYSTORE_PASSWORD and KEY_PASSWORD secrets."
                exit 1
              fi
            else
              echo "::error::Failed to convert keystore to BKS."
              echo "::error::If your key password differs from KEYSTORE_PASSWORD, set KEY_PASSWORD secret."
              exit 1
            fi
          fi

          if [ ! -f "$DEST_KEYSTORE" ]; then
            echo "::error::Failed to create converted BKS keystore."
            exit 1
          fi

          list_aliases() {
            keytool -list \
              -keystore "$DEST_KEYSTORE" \
              -storetype BKS \
              -storepass "$KEYSTORE_PASSWORD" \
              -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider \
              -providerpath "$BCPROV_JAR" \
              2>/dev/null | awk -F, '/,/{print $1}' | sed '/^$/d'
          }

          mapfile -t KEY_ALIASES < <(list_aliases)
          if [ "${#KEY_ALIASES[@]}" -eq 0 ]; then
            echo "::error::No aliases found in converted keystore."
            exit 1
          fi

          KEY_ALIAS="$KEY_ALIAS_INPUT"
          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="${KEY_ALIASES[0]}"
            echo "::notice::No KEY_ALIAS provided; using alias '$KEY_ALIAS'."
          else
            ALIAS_FOUND=false
            for a in "${KEY_ALIASES[@]}"; do
              if [ "$a" = "$KEY_ALIAS" ]; then
                ALIAS_FOUND=true
                break
              fi
            done
            if [ "$ALIAS_FOUND" = false ]; then
              echo "::error::KEY_ALIAS '$KEY_ALIAS' was not found in the converted keystore."
              echo "::notice::Available aliases: ${KEY_ALIASES[*]}"
              exit 1
            fi
          fi

          echo "path=$DEST_KEYSTORE" >> "$GITHUB_OUTPUT"
          echo "alias=$KEY_ALIAS" >> "$GITHUB_OUTPUT"
          echo "::notice::Prepared BKS keystore for Morphe signing."

      - name: Patch ${{ matrix.name }} with morphe-cli
        id: patch
        run: |
          set -euo pipefail
          JAR="$(ls -1 $TOOLS_DIR/morphe-cli-*-all.jar | head -n1)"
          MPP="$(ls -1 $TOOLS_DIR/patches-*.mpp | head -n1)"
          APK="${{ steps.getapk.outputs.apk }}"
          APK_VERSION="${{ steps.getapk.outputs.version }}"
          APK_NORM="${APK#./}"
          KEYSTORE_FILE="${{ steps.keystore.outputs.path }}"
          KEY_ALIAS="${{ steps.keystore.outputs.alias }}"
          KEYSTORE_PASSWORD="${{ secrets.KEYSTORE_PASSWORD }}"
          KEY_ENTRY_PASS="${{ secrets.KEY_PASSWORD }}"
          if [ -z "$KEY_ENTRY_PASS" ]; then
            KEY_ENTRY_PASS="$KEYSTORE_PASSWORD"
          fi

          # Signed builds are enforced.
          if [ -z "$KEYSTORE_FILE" ] || [ ! -f "$KEYSTORE_FILE" ]; then
            echo "::error::Prepared keystore file not found."
            exit 1
          fi
          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "::error::KEYSTORE_PASSWORD secret is required for signing."
            exit 1
          fi
          KEY_ARGS=(--keystore="$KEYSTORE_FILE" --keystore-password="$KEYSTORE_PASSWORD" --keystore-entry-alias="$KEY_ALIAS" --keystore-entry-password="$KEY_ENTRY_PASS")

          # Build disable flags from patches.json directly (safe handling for spaces in names).
          PATCH_ARGS=()
          while IFS= read -r patch_name; do
            [ -z "$patch_name" ] && continue
            PATCH_ARGS+=("-d" "$patch_name")
          done < <(jq -r --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries[] | select(.value == false) | .key' patches.json)

          # Create marker file so we can deterministically find CLI output files created in this step.
          MARKER="$RUNNER_TEMP/morphe_${{ matrix.name }}_start.marker"
          : > "$MARKER"

          PATCH_LOG="$RUNNER_TEMP/morphe_patch_${{ matrix.name }}.log"
          PATCH_TMP_DIR="$RUNNER_TEMP/morphe_${{ matrix.name }}"

          run_patch() {
            local mode="$1"
            shift
            echo "::notice::Running morphe-cli for ${{ matrix.appId }} (v$APK_VERSION, mode=$mode)..."
            set +e
            "$@" 2>&1 | tee "$PATCH_LOG"
            local rc=${PIPESTATUS[0]}
            set -e
            return "$rc"
          }

          build_patch_cmd() {
            local -a cmd=(java -jar "$JAR" patch --patches="$MPP")
            cmd+=("${KEY_ARGS[@]}")
            cmd+=(--temporary-files-path="$PATCH_TMP_DIR" --purge)
            cmd+=("${PATCH_ARGS[@]}")
            cmd+=("$APK")
            printf '%s\0' "${cmd[@]}"
          }

          mapfile -d '' -t PATCH_CMD < <(build_patch_cmd)
          if ! run_patch "signed-required" "${PATCH_CMD[@]}"; then
            if grep -q "Wrong version of key store" "$PATCH_LOG"; then
              echo "::error::Morphe could not read the provided keystore (Wrong version of key store)."
              echo "::error::Ensure KEYSTORE_BASE64 decodes to a valid keystore and KEYSTORE_PASSWORD/KEY_PASSWORD are correct."
            fi
            exit 1
          fi

          # Collect output: prefer APKs newer than marker and not equal to input APK.
          OUT_APK="$( \
            { find . -maxdepth 1 -type f -name "*.apk" -newer "$MARKER" -printf '%T@ %p\n' || true; \
              find "$APKS_DIR" -maxdepth 1 -type f -name "*.apk" -newer "$MARKER" -printf '%T@ %p\n' || true; } \
            | sort -nr \
            | cut -d' ' -f2- \
            | awk -v apk="$APK_NORM" '
                {
                  line=$0
                  sub(/^\.\//, "", line)
                  if (line != "" && line != apk && out == "") out=line
                }
                END { if (out != "") print out }
              ' \
          )"

          # Fallback: pick newest non-input APK if timestamps are not reliable.
          if [ -z "$OUT_APK" ] || [ ! -f "$OUT_APK" ]; then
            OUT_APK="$( \
              { find . -maxdepth 1 -type f -name "*.apk" -printf '%T@ %p\n' || true; \
                find "$APKS_DIR" -maxdepth 1 -type f -name "*.apk" -printf '%T@ %p\n' || true; } \
              | sort -nr \
              | cut -d' ' -f2- \
              | awk -v apk="$APK_NORM" '
                  {
                    line=$0
                    sub(/^\.\//, "", line)
                    if (line != "" && line != apk && out == "") out=line
                  }
                  END { if (out != "") print out }
                ' \
            )"
          fi
          if [ -z "$OUT_APK" ] || [ ! -f "$OUT_APK" ]; then
            echo "::error::Could not locate patched APK output"
            echo "::notice::Files in current directory:"
            ls -la
            echo "::notice::Files in $APKS_DIR:"
            ls -la "$APKS_DIR" || true
            exit 1
          fi
          
          # Rename with version info
          OUTPUT_NAME="${{ matrix.name }}-${PATCHES_VERSION}-v${APK_VERSION}.apk"
          mv "$OUT_APK" "$OUT_DIR/$OUTPUT_NAME"
          echo "output=$OUTPUT_NAME" >> "$GITHUB_OUTPUT"

      - name: Upload patched ${{ matrix.name }}
        uses: actions/upload-artifact@v4
        with:
          name: morphe-${{ matrix.name }}-${{ env.PATCHES_VERSION }}-v${{ steps.getapk.outputs.version }}
          path: out/${{ steps.patch.outputs.output }}

      - name: Publish release for ${{ matrix.name }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          APK_FILE="out/${{ steps.patch.outputs.output }}"
          APK_VERSION="${{ steps.getapk.outputs.version }}"
          VERSION_TAG="morphe-${{ matrix.name }}-${PATCHES_VERSION}-v${APK_VERSION}"
          VERSION_TITLE="Morphe ${{ matrix.name }} ${PATCHES_VERSION} (base ${APK_VERSION})"
          LATEST_TAG="morphe-${{ matrix.name }}-latest"
          LATEST_TITLE="Morphe ${{ matrix.name }} latest (${PATCHES_VERSION}, base ${APK_VERSION})"
          LATEST_ASSET_NAME="${{ matrix.name }}-latest.apk"

          if [ ! -f "$APK_FILE" ]; then
            echo "::error::APK file not found for release: $APK_FILE"
            exit 1
          fi

          RELEASE_NOTES_VERSIONED="$(cat <<EOF
          Patched app: ${{ matrix.appId }}
          Base app version: ${APK_VERSION}
          Patches version: ${PATCHES_VERSION}
          CLI version: ${CLI_VERSION}
          EOF
          )"

          RELEASE_NOTES_LATEST="$(cat <<EOF
          Rolling latest release for ${{ matrix.appId }}.
          Current base app version: ${APK_VERSION}
          Current patches version: ${PATCHES_VERSION}
          Current CLI version: ${CLI_VERSION}
          Versioned tag for this build: ${VERSION_TAG}
          EOF
          )"

          publish_release() {
            local tag="$1"
            local title="$2"
            local notes="$3"
            local asset="$4"
            if gh release view "$tag" >/dev/null 2>&1; then
              echo "::notice::Release $tag exists; updating asset and notes."
              gh release upload "$tag" "$asset" --clobber
              gh release edit "$tag" --title "$title" --notes "$notes"
            else
              echo "::notice::Creating release $tag"
              gh release create "$tag" "$asset" \
                --title "$title" \
                --notes "$notes"
            fi
          }

          # Historical immutable-style release tag per build.
          publish_release \
            "$VERSION_TAG" \
            "$VERSION_TITLE" \
            "$RELEASE_NOTES_VERSIONED" \
            "$APK_FILE"

          # Stable tag for Obtainium (no regex needed), asset name is fixed and overwritten.
          publish_release \
            "$LATEST_TAG" \
            "$LATEST_TITLE" \
            "$RELEASE_NOTES_LATEST" \
            "$APK_FILE#${LATEST_ASSET_NAME}"
          echo "::notice::Published tags: ${VERSION_TAG}, ${LATEST_TAG}"

  update-state:
    needs: [check-versions, build]
    if: needs.build.result == 'success' && needs.check-versions.outputs.should-build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update state.json
        run: |
          set -euo pipefail
          jq --arg patches "${{ needs.check-versions.outputs.patches-version }}" \
             --arg cli "${{ needs.check-versions.outputs.cli-version }}" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             '. + {
               "patches_version": $patches,
               "cli_version": $cli,
               "last_build": $timestamp,
               "status": "success"
             }' state.json > state.json.tmp && mv state.json.tmp state.json

      - name: Commit state.json
        run: |
          set -euo pipefail
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add state.json
          git commit -m "chore: update state.json - patches ${{ needs.check-versions.outputs.patches-version }}, cli ${{ needs.check-versions.outputs.cli-version }}" || true
          git push || true
