name: Build Morphe‑patched apps

on:
  workflow_dispatch:
  schedule:
    - cron: "15 5 * * *" # daily at 05:15 UTC

permissions:
  contents: write
  actions: read

jobs:
  check-versions:
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.version-check.outputs.should-build }}
      patches-version: ${{ steps.version-check.outputs.patches-version }}
      cli-version: ${{ steps.version-check.outputs.cli-version }}
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check latest versions
        id: version-check
        run: |
          set -euo pipefail
          
          # Get latest versions
          PATCHES_TAG="$(gh release view --repo MorpheApp/morphe-patches --json tagName -q .tagName)"
          CLI_TAG="$(gh release view --repo MorpheApp/morphe-cli --json tagName -q .tagName)"
          
          echo "patches-version=$PATCHES_TAG" >> "$GITHUB_OUTPUT"
          echo "cli-version=$CLI_TAG" >> "$GITHUB_OUTPUT"
          
          # Load previous state
          if [ -f state.json ]; then
            PREV_PATCHES=$(jq -r '.patches_version // "none"' state.json)
            PREV_CLI=$(jq -r '.cli_version // "none"' state.json)
          else
            PREV_PATCHES="none"
            PREV_CLI="none"
          fi
          
          # Check if versions changed
          if [ "$PATCHES_TAG" != "$PREV_PATCHES" ] || [ "$CLI_TAG" != "$PREV_CLI" ]; then
            echo "should-build=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Version changes detected. Patches: $PREV_PATCHES → $PATCHES_TAG, CLI: $PREV_CLI → $CLI_TAG"
          else
            echo "should-build=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No version changes detected. Skipping build."
          fi

  build:
    needs: check-versions
    if: needs.check-versions.outputs.should-build == 'true'
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: youtube
            appId: com.google.android.youtube
          - name: ytmusic
            appId: com.google.android.apps.youtube.music
          - name: reddit
            appId: com.reddit.frontpage

    env:
      # Where we'll put tools/artifacts
      GH_TOKEN: ${{ github.token }}
      TOOLS_DIR: tools
      APKS_DIR: apps
      OUT_DIR: out
      PATCHES_VERSION: ${{ needs.check-versions.outputs.patches-version }}
      CLI_VERSION: ${{ needs.check-versions.outputs.cli-version }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java (for morphe-cli)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17" # any current LTS JRE is fine to run the CLI [9](https://aur.archlinux.org/packages/morphe-cli)

      - name: Install jq & apkeep
        run: |
          set -euo pipefail
          
          echo "::notice::Installing dependencies..."
          sudo apt-get update -y
          sudo apt-get install -y jq curl unzip libbcprov-java
          
          # Install Rust (needed for apkeep)
          echo "::notice::Installing Rust toolchain..."
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
          source "$HOME/.cargo/env"
          
          # Install apkeep from source (most reliable method)
          echo "::notice::Building and installing apkeep from source..."
          cargo install apkeep --locked --quiet
          
          # Verify installation
          if ! command -v apkeep &> /dev/null; then
            echo "::error::apkeep installation failed"
            exit 1
          fi
          
          echo "::notice::apkeep installed successfully"
          apkeep --version

      - name: Prepare dirs
        run: |
          mkdir -p "$TOOLS_DIR" "$APKS_DIR" "$OUT_DIR"

      - name: Get latest Morphe patches + CLI
        id: morphe
        run: |
          set -euo pipefail

          # Reuse versions already resolved in check-versions job.
          PATCHES_TAG="${PATCHES_VERSION}"
          CLI_TAG="${CLI_VERSION}"
          if [ -z "$PATCHES_TAG" ] || [ -z "$CLI_TAG" ]; then
            echo "::error::Missing release version(s). patches='$PATCHES_TAG' cli='$CLI_TAG'"
            exit 1
          fi

          echo "patches_tag=$PATCHES_TAG" >> "$GITHUB_OUTPUT"
          gh release download "$PATCHES_TAG" \
            --repo MorpheApp/morphe-patches \
            --pattern 'patches-*.mpp' \
            --dir "$TOOLS_DIR" >/dev/null
          # also fetch patches-list.json to know available patches by app [3](https://github.com/MorpheApp/morphe-patches)
          curl -fsSL "https://raw.githubusercontent.com/MorpheApp/morphe-patches/${PATCHES_TAG}/patches-list.json" \
            -o "$TOOLS_DIR/patches-list.json"

          echo "cli_tag=$CLI_TAG" >> "$GITHUB_OUTPUT"
          gh release download "$CLI_TAG" \
            --repo MorpheApp/morphe-cli \
            --pattern 'morphe-cli-*-all.jar' \
            --dir "$TOOLS_DIR" >/dev/null

      - name: Ensure patches.json exists (generate defaults if missing)
        run: |
          set -euo pipefail
          if [ ! -f patches.json ]; then
            echo "::notice::No patches.json found; generating with all patches enabled by default."

            # Some releases expose an array "patches", some a flat list; handle both.
            jq -n --slurpfile plist "$TOOLS_DIR/patches-list.json" '
              def base($pkg):
                ($plist[0].patches // $plist[0]) # handle { "patches": [...] } or just [...]
                | map(select( (.compatiblePackages // .compatible_packages)
                               | any(.name == $pkg or .packageName == $pkg) ))
                | map({ (.name): true }) | add;

              {
                "com.google.android.youtube": base("com.google.android.youtube"),
                "com.google.android.apps.youtube.music": base("com.google.android.apps.youtube.music"),
                "com.reddit.frontpage": base("com.reddit.frontpage")
              }' > patches.json
          fi
          echo "Generated/using patches.json:"
          jq 'keys' patches.json

      - name: Resolve supported version for ${{ matrix.appId }}
        id: targetver
        run: |
          set -euo pipefail

          DISABLED_PATCHES_JSON="$(jq -c --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries | map(select(.value == false) | .key)' patches.json)"

          STRICT_VERSIONS="$(
            jq -r \
              --arg pkg "${{ matrix.appId }}" \
              --argjson disabled "$DISABLED_PATCHES_JSON" \
              '
              (.patches // .)
              | map(
                  select(
                    ((.use // true) == true)
                    and ((.name as $n | ($disabled | index($n)) | not))
                    and ((.compatiblePackages[$pkg]? | type) == "array")
                  )
                )
              | map(.compatiblePackages[$pkg]) as $version_lists
              | if ($version_lists | length) == 0 then
                  empty
                else
                  reduce $version_lists[] as $current ($version_lists[0];
                    map(select($current | index(.)))
                  )[]
                end
              ' "$TOOLS_DIR/patches-list.json" || true
          )"

          VERSION_COUNTS="$(
            jq -r \
              --arg pkg "${{ matrix.appId }}" \
              --argjson disabled "$DISABLED_PATCHES_JSON" \
              '
              (.patches // .) as $patches
              | $patches
              | map(
                  select(
                    ((.use // true) == true)
                    and ((.name as $n | ($disabled | index($n)) | not))
                    and ((.compatiblePackages[$pkg]? | type) == "array")
                  )
                )
              | map(.compatiblePackages[$pkg][])
              | sort
              | group_by(.)
              | map([length, .[0]])
              | .[]
              | @tsv
              ' "$TOOLS_DIR/patches-list.json" || true
          )"

          TARGET_VERSION=""
          TARGET_VERSIONS=""
          if [ -n "$STRICT_VERSIONS" ]; then
            TARGET_VERSIONS="$(printf '%s\n' "$STRICT_VERSIONS" | sort -Vr | paste -sd, -)"
            TARGET_VERSION="$(printf '%s\n' "$STRICT_VERSIONS" | sort -Vr | head -n1)"
          elif [ -n "$VERSION_COUNTS" ]; then
            TARGET_VERSIONS="$(printf '%s\n' "$VERSION_COUNTS" | sort -t $'\t' -k1,1nr -k2,2Vr | cut -f2 | paste -sd, -)"
            TARGET_VERSION="$(printf '%s\n' "$VERSION_COUNTS" | sort -t $'\t' -k1,1nr -k2,2Vr | head -n1 | cut -f2)"
          fi

          if [ -n "$TARGET_VERSION" ]; then
            echo "version=$TARGET_VERSION" >> "$GITHUB_OUTPUT"
            echo "versions=$TARGET_VERSIONS" >> "$GITHUB_OUTPUT"
            echo "::notice::Selected most compatible version for ${{ matrix.appId }}: $TARGET_VERSION"
          else
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "versions=" >> "$GITHUB_OUTPUT"
            echo "::warning::Could not resolve a supported version from patches list; falling back to latest available download."
          fi

      - name: Download supported APK for ${{ matrix.appId }}
        id: getapk
        run: |
          set -euo pipefail
          
          echo "::notice::Downloading APK for ${{ matrix.appId }}..."
          TARGET_VERSION="${{ steps.targetver.outputs.version }}"
          TARGET_VERSIONS="${{ steps.targetver.outputs.versions }}"
          
          # Create output directory if it doesn't exist
          mkdir -p "$APKS_DIR"
          rm -f "$APKS_DIR"/* || true
          : > apkeep.log
          
          find_package_candidate() {
            find "$APKS_DIR" -type f \
              \( -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" \) \
              -printf '%T@ %p\n' | sort -nr | head -n1 | cut -d' ' -f2- || true
          }

          download_with_apkeep() {
            local version="$1"
            local -a args=(-a "${{ matrix.appId }}" -d apk-pure "$APKS_DIR")
            if [ -n "$version" ]; then
              args+=(--version "$version")
            fi
            apkeep "${args[@]}" 2>&1 | tee -a apkeep.log
          }

          APK_CANDIDATE=""
          RESOLVED_DOWNLOAD_VERSION=""

          if [ -n "$TARGET_VERSIONS" ]; then
            IFS=',' read -r -a VERSION_LIST <<< "$TARGET_VERSIONS"
            for v in "${VERSION_LIST[@]}"; do
              [ -z "$v" ] && continue
              echo "::notice::Trying supported version $v for ${{ matrix.appId }}..."
              if download_with_apkeep "$v"; then
                echo "::notice::apkeep completed for version $v"
              else
                echo "::warning::apkeep failed for version $v"
              fi

              APK_CANDIDATE="$(find_package_candidate)"
              if [ -n "$APK_CANDIDATE" ] && [ -f "$APK_CANDIDATE" ]; then
                RESOLVED_DOWNLOAD_VERSION="$v"
                break
              fi
            done
          fi

          if [ -z "$APK_CANDIDATE" ]; then
            echo "::warning::No package downloaded from supported versions. Retrying latest available package."
            if download_with_apkeep ""; then
              echo "::notice::apkeep completed for latest available package"
            else
              echo "::warning::apkeep failed for latest available package"
            fi
            APK_CANDIDATE="$(find_package_candidate)"
          fi

          if [ -n "$APK_CANDIDATE" ] && [ -f "$APK_CANDIDATE" ]; then
            echo "::notice::Found package in $APKS_DIR: $APK_CANDIDATE"
          else
            # Fallback: check current directory and move into APKS_DIR.
            APK_FOUND="$(find . -maxdepth 1 -type f \( -name "*${{ matrix.appId }}*.apk" -o -name "*${{ matrix.appId }}*.xapk" -o -name "*${{ matrix.appId }}*.apkm" -o -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" \) | head -n1 || true)"
            if [ -n "$APK_FOUND" ] && [ -f "$APK_FOUND" ]; then
              echo "::notice::Found package in current dir: $APK_FOUND"
              mv "$APK_FOUND" "$APKS_DIR/"
              APK_CANDIDATE="$APKS_DIR/$(basename "$APK_FOUND")"
            else
              echo "::error::No APK found after download"
              echo "::notice::Files in current directory:"
              ls -la
              echo "::notice::Files in $APKS_DIR:"
              ls -la "$APKS_DIR" || true
              echo "::notice::apkeep log:"
              cat apkeep.log || true
              exit 1
            fi
          fi

          # If downloader produced split package (.xapk/.apkm), extract an installable APK.
          APK_PATH="$APK_CANDIDATE"
          case "$APK_CANDIDATE" in
            *.xapk|*.apkm)
              echo "::notice::Split package detected ($APK_CANDIDATE); extracting APK..."
              XAPK_TMP="$RUNNER_TEMP/xapk_${{ matrix.name }}"
              rm -rf "$XAPK_TMP"
              mkdir -p "$XAPK_TMP"
              unzip -o -q "$APK_CANDIDATE" '*.apk' -d "$XAPK_TMP" || true

              EXTRACTED_APK="$(find "$XAPK_TMP" -type f -name "base.apk" | head -n1 || true)"
              if [ -z "$EXTRACTED_APK" ]; then
                # Fallback: choose the largest APK from the archive.
                EXTRACTED_APK="$(find "$XAPK_TMP" -type f -name "*.apk" -printf '%s %p\n' | sort -nr | head -n1 | cut -d' ' -f2- || true)"
              fi

              if [ -z "$EXTRACTED_APK" ] || [ ! -f "$EXTRACTED_APK" ]; then
                echo "::error::Could not extract APK from split package: $APK_CANDIDATE"
                echo "::notice::Archive APK contents:"
                find "$XAPK_TMP" -type f -name "*.apk" -print || true
                exit 1
              fi

              APK_PATH="$APKS_DIR/${{ matrix.appId }}.apk"
              cp "$EXTRACTED_APK" "$APK_PATH"
              echo "::notice::Extracted APK: $APK_PATH"
              ;;
          esac
          
          if [ ! -f "$APK_PATH" ]; then
            echo "::error::APK path check failed: $APK_PATH"
            exit 1
          fi
          
          echo "apk=$APK_PATH" >> "$GITHUB_OUTPUT"
          
          # Extract version from APK filename
          APK_FILENAME=$(basename "$APK_PATH")
          APK_VERSION=$(echo "$APK_FILENAME" | grep -oE '[0-9]+(\.[0-9]+){2,}' | head -1 || true)
          if [ -z "$APK_VERSION" ] && [ -n "$RESOLVED_DOWNLOAD_VERSION" ]; then
            APK_VERSION="$RESOLVED_DOWNLOAD_VERSION"
          fi
          if [ -z "$APK_VERSION" ] && [ -n "$TARGET_VERSION" ]; then
            APK_VERSION="$TARGET_VERSION"
          fi
          if [ -z "$APK_VERSION" ]; then
            APK_VERSION="unknown"
          fi
          echo "version=$APK_VERSION" >> "$GITHUB_OUTPUT"
          echo "::notice::Downloaded ${{ matrix.name }} → $APK_PATH (v$APK_VERSION)"

      - name: Prepare signing keystore (required)
        id: keystore
        run: |
          set -euo pipefail

          KEYSTORE_B64="${{ secrets.KEYSTORE_BASE64 }}"
          KEYSTORE_PASSWORD="${{ secrets.KEYSTORE_PASSWORD }}"
          KEY_PASSWORD="${{ secrets.KEY_PASSWORD }}"
          KEY_ALIAS_INPUT="${{ secrets.KEY_ALIAS }}"

          if [ -z "$KEYSTORE_B64" ]; then
            echo "::error::KEYSTORE_BASE64 secret is required (signed builds are enforced)."
            exit 1
          fi
          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "::error::KEYSTORE_PASSWORD secret is required (signed builds are enforced)."
            exit 1
          fi
          if [ -z "$KEY_PASSWORD" ]; then
            KEY_PASSWORD="$KEYSTORE_PASSWORD"
          fi

          BCPROV_JAR="$(ls -1 /usr/share/java/bcprov*.jar 2>/dev/null | head -n1 || true)"
          if [ -z "$BCPROV_JAR" ] || [ ! -f "$BCPROV_JAR" ]; then
            echo "::error::BouncyCastle provider JAR not found on runner."
            exit 1
          fi

          RAW_KEYSTORE="$TOOLS_DIR/source.keystore"
          DEST_KEYSTORE="$TOOLS_DIR/morphe.bks"
          rm -f "$RAW_KEYSTORE" "$DEST_KEYSTORE"

          echo "$KEYSTORE_B64" | base64 -d > "$RAW_KEYSTORE"

          detect_keystore_type() {
            local type="$1"
            local -a args=(keytool -list -keystore "$RAW_KEYSTORE" -storetype "$type" -storepass "$KEYSTORE_PASSWORD")
            if [ "$type" = "BKS" ] || [ "$type" = "UBER" ]; then
              args+=(-providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath "$BCPROV_JAR")
            fi
            "${args[@]}" >/dev/null 2>&1
          }

          SRC_TYPE=""
          for t in PKCS12 JKS BKS UBER; do
            if detect_keystore_type "$t"; then
              SRC_TYPE="$t"
              break
            fi
          done

          if [ -z "$SRC_TYPE" ]; then
            echo "::error::Could not detect source keystore type using PKCS12/JKS/BKS/UBER."
            exit 1
          fi
          echo "::notice::Detected source keystore type: $SRC_TYPE"

          IMPORT_ARGS=(
            keytool -importkeystore -noprompt
            -srckeystore "$RAW_KEYSTORE"
            -srcstoretype "$SRC_TYPE"
            -srcstorepass "$KEYSTORE_PASSWORD"
            -destkeystore "$DEST_KEYSTORE"
            -deststoretype BKS
            -deststorepass "$KEYSTORE_PASSWORD"
            -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider
            -providerpath "$BCPROV_JAR"
          )
          if [ -n "$KEY_PASSWORD" ]; then
            IMPORT_ARGS+=(-srckeypass "$KEY_PASSWORD" -destkeypass "$KEY_PASSWORD")
          fi
          "${IMPORT_ARGS[@]}" >/dev/null

          if [ ! -f "$DEST_KEYSTORE" ]; then
            echo "::error::Failed to create converted BKS keystore."
            exit 1
          fi

          list_aliases() {
            keytool -list \
              -keystore "$DEST_KEYSTORE" \
              -storetype BKS \
              -storepass "$KEYSTORE_PASSWORD" \
              -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider \
              -providerpath "$BCPROV_JAR" \
              2>/dev/null | awk -F, '/,/{print $1}' | sed '/^$/d'
          }

          mapfile -t KEY_ALIASES < <(list_aliases)
          if [ "${#KEY_ALIASES[@]}" -eq 0 ]; then
            echo "::error::No aliases found in converted keystore."
            exit 1
          fi

          KEY_ALIAS="$KEY_ALIAS_INPUT"
          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="${KEY_ALIASES[0]}"
            echo "::notice::No KEY_ALIAS provided; using alias '$KEY_ALIAS'."
          else
            ALIAS_FOUND=false
            for a in "${KEY_ALIASES[@]}"; do
              if [ "$a" = "$KEY_ALIAS" ]; then
                ALIAS_FOUND=true
                break
              fi
            done
            if [ "$ALIAS_FOUND" = false ]; then
              echo "::error::KEY_ALIAS '$KEY_ALIAS' was not found in the converted keystore."
              echo "::notice::Available aliases: ${KEY_ALIASES[*]}"
              exit 1
            fi
          fi

          echo "path=$DEST_KEYSTORE" >> "$GITHUB_OUTPUT"
          echo "alias=$KEY_ALIAS" >> "$GITHUB_OUTPUT"
          echo "::notice::Prepared BKS keystore for Morphe signing."

      - name: Patch ${{ matrix.name }} with morphe-cli
        id: patch
        run: |
          set -euo pipefail
          JAR="$(ls -1 $TOOLS_DIR/morphe-cli-*-all.jar | head -n1)"
          MPP="$(ls -1 $TOOLS_DIR/patches-*.mpp | head -n1)"
          APK="${{ steps.getapk.outputs.apk }}"
          APK_VERSION="${{ steps.getapk.outputs.version }}"
          APK_NORM="${APK#./}"
          KEYSTORE_FILE="${{ steps.keystore.outputs.path }}"
          KEY_ALIAS="${{ steps.keystore.outputs.alias }}"
          KEYSTORE_PASSWORD="${{ secrets.KEYSTORE_PASSWORD }}"
          KEY_ENTRY_PASS="${{ secrets.KEY_PASSWORD }}"
          if [ -z "$KEY_ENTRY_PASS" ]; then
            KEY_ENTRY_PASS="$KEYSTORE_PASSWORD"
          fi

          # Signed builds are enforced.
          if [ -z "$KEYSTORE_FILE" ] || [ ! -f "$KEYSTORE_FILE" ]; then
            echo "::error::Prepared keystore file not found."
            exit 1
          fi
          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "::error::KEYSTORE_PASSWORD secret is required for signing."
            exit 1
          fi
          KEY_ARGS=(--keystore="$KEYSTORE_FILE" --keystore-password="$KEYSTORE_PASSWORD" --keystore-entry-alias="$KEY_ALIAS" --keystore-entry-password="$KEY_ENTRY_PASS")

          # Build disable flags from patches.json directly (safe handling for spaces in names).
          PATCH_ARGS=()
          while IFS= read -r patch_name; do
            [ -z "$patch_name" ] && continue
            PATCH_ARGS+=("-d" "$patch_name")
          done < <(jq -r --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries[] | select(.value == false) | .key' patches.json)

          # Create marker file so we can deterministically find CLI output files created in this step.
          MARKER="$RUNNER_TEMP/morphe_${{ matrix.name }}_start.marker"
          : > "$MARKER"

          PATCH_LOG="$RUNNER_TEMP/morphe_patch_${{ matrix.name }}.log"
          PATCH_TMP_DIR="$RUNNER_TEMP/morphe_${{ matrix.name }}"

          run_patch() {
            local mode="$1"
            shift
            echo "::notice::Running morphe-cli for ${{ matrix.appId }} (v$APK_VERSION, mode=$mode)..."
            set +e
            "$@" 2>&1 | tee "$PATCH_LOG"
            local rc=${PIPESTATUS[0]}
            set -e
            return "$rc"
          }

          build_patch_cmd() {
            local -a cmd=(java -jar "$JAR" patch --patches="$MPP")
            cmd+=("${KEY_ARGS[@]}")
            cmd+=(--temporary-files-path="$PATCH_TMP_DIR" --purge)
            cmd+=("${PATCH_ARGS[@]}")
            cmd+=("$APK")
            printf '%s\0' "${cmd[@]}"
          }

          mapfile -d '' -t PATCH_CMD < <(build_patch_cmd)
          if ! run_patch "signed-required" "${PATCH_CMD[@]}"; then
            if grep -q "Wrong version of key store" "$PATCH_LOG"; then
              echo "::error::Morphe could not read the provided keystore (Wrong version of key store)."
              echo "::error::Ensure KEYSTORE_BASE64 decodes to a valid keystore and KEYSTORE_PASSWORD/KEY_PASSWORD are correct."
            fi
            exit 1
          fi

          # Collect output: prefer APKs newer than marker and not equal to input APK.
          OUT_APK="$( \
            { find . -maxdepth 1 -type f -name "*.apk" -newer "$MARKER" -printf '%T@ %p\n' || true; \
              find "$APKS_DIR" -maxdepth 1 -type f -name "*.apk" -newer "$MARKER" -printf '%T@ %p\n' || true; } \
            | sort -nr \
            | cut -d' ' -f2- \
            | awk -v apk="$APK_NORM" '
                {
                  line=$0
                  sub(/^\.\//, "", line)
                  if (line != "" && line != apk && out == "") out=line
                }
                END { if (out != "") print out }
              ' \
          )"

          # Fallback: pick newest non-input APK if timestamps are not reliable.
          if [ -z "$OUT_APK" ] || [ ! -f "$OUT_APK" ]; then
            OUT_APK="$( \
              { find . -maxdepth 1 -type f -name "*.apk" -printf '%T@ %p\n' || true; \
                find "$APKS_DIR" -maxdepth 1 -type f -name "*.apk" -printf '%T@ %p\n' || true; } \
              | sort -nr \
              | cut -d' ' -f2- \
              | awk -v apk="$APK_NORM" '
                  {
                    line=$0
                    sub(/^\.\//, "", line)
                    if (line != "" && line != apk && out == "") out=line
                  }
                  END { if (out != "") print out }
                ' \
            )"
          fi
          if [ -z "$OUT_APK" ] || [ ! -f "$OUT_APK" ]; then
            echo "::error::Could not locate patched APK output"
            echo "::notice::Files in current directory:"
            ls -la
            echo "::notice::Files in $APKS_DIR:"
            ls -la "$APKS_DIR" || true
            exit 1
          fi
          
          # Rename with version info
          OUTPUT_NAME="${{ matrix.name }}-${PATCHES_VERSION}-v${APK_VERSION}.apk"
          mv "$OUT_APK" "$OUT_DIR/$OUTPUT_NAME"
          echo "output=$OUTPUT_NAME" >> "$GITHUB_OUTPUT"

      - name: Upload patched ${{ matrix.name }}
        uses: actions/upload-artifact@v4
        with:
          name: morphe-${{ matrix.name }}-${{ env.PATCHES_VERSION }}-v${{ steps.getapk.outputs.version }}
          path: out/${{ steps.patch.outputs.output }}

  update-state:
    needs: [check-versions, build]
    if: needs.build.result == 'success' && needs.check-versions.outputs.should-build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update state.json
        run: |
          set -euo pipefail
          jq --arg patches "${{ needs.check-versions.outputs.patches-version }}" \
             --arg cli "${{ needs.check-versions.outputs.cli-version }}" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             '. + {
               "patches_version": $patches,
               "cli_version": $cli,
               "last_build": $timestamp,
               "status": "success"
             }' state.json > state.json.tmp && mv state.json.tmp state.json

      - name: Commit state.json
        run: |
          set -euo pipefail
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add state.json
          git commit -m "chore: update state.json - patches ${{ needs.check-versions.outputs.patches-version }}, cli ${{ needs.check-versions.outputs.cli-version }}" || true
          git push || true
