name: Build Morphe‑patched apps

on:
  workflow_dispatch:
  schedule:
    - cron: "15 5 * * *" # daily at 05:15 UTC

permissions:
  contents: write
  actions: read

jobs:
  check-versions:
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.version-check.outputs.should-build }}
      patches-version: ${{ steps.version-check.outputs.patches-version }}
      cli-version: ${{ steps.version-check.outputs.cli-version }}
      patches-branch: ${{ steps.version-check.outputs.patches-branch }}
      cli-branch: ${{ steps.version-check.outputs.cli-branch }}
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check latest versions
        id: version-check
        run: |
          set -euo pipefail

          # Read channel selection from patches.json metadata.
          # Supported values: main, dev.
          PATCHES_BRANCH="main"
          CLI_BRANCH="main"
          if [ -f patches.json ] && jq empty patches.json >/dev/null 2>&1; then
            PATCHES_BRANCH="$(jq -r '(.["__morphe"]?.branches?.morphe_patches // "main") | ascii_downcase' patches.json)"
            CLI_BRANCH="$(jq -r '(.["__morphe"]?.branches?.morphe_cli // "main") | ascii_downcase' patches.json)"
          fi

          if [ "$PATCHES_BRANCH" != "main" ] && [ "$PATCHES_BRANCH" != "dev" ]; then
            echo "::warning::Invalid morphe_patches branch '$PATCHES_BRANCH' in patches.json. Falling back to 'main'."
            PATCHES_BRANCH="main"
          fi
          if [ "$CLI_BRANCH" != "main" ] && [ "$CLI_BRANCH" != "dev" ]; then
            echo "::warning::Invalid morphe_cli branch '$CLI_BRANCH' in patches.json. Falling back to 'main'."
            CLI_BRANCH="main"
          fi

          resolve_release_tag() {
            local repo="$1"
            local branch="$2"
            local stable_tag=""
            local selected_tag=""

            stable_tag="$(gh release view --repo "$repo" --json tagName -q .tagName || true)"
            if [ "$branch" = "main" ]; then
              selected_tag="$stable_tag"
            else
              selected_tag="$(
                gh api "repos/${repo}/releases?per_page=100" --jq '
                  [ .[]
                    | select(
                        (.draft != true)
                        and (
                        ((.target_commitish // "" | ascii_downcase) == "dev")
                        or (.prerelease == true)
                        or ((.tag_name // "" | ascii_downcase | test("(^|[-_.])(dev|beta|alpha|rc)")))
                        )
                      )
                  ][0].tag_name // empty
                ' || true
              )"
              if [ -z "$selected_tag" ]; then
                echo "::warning::No dev-style release found for ${repo}; falling back to latest release tag."
                selected_tag="$stable_tag"
              fi
            fi

            if [ -z "$selected_tag" ]; then
              echo "::error::Could not resolve release tag for ${repo} (branch=${branch})."
              exit 1
            fi
            echo "$selected_tag"
          }

          PATCHES_TAG="$(resolve_release_tag "MorpheApp/morphe-patches" "$PATCHES_BRANCH")"
          CLI_TAG="$(resolve_release_tag "MorpheApp/morphe-cli" "$CLI_BRANCH")"

          echo "patches-version=$PATCHES_TAG" >> "$GITHUB_OUTPUT"
          echo "cli-version=$CLI_TAG" >> "$GITHUB_OUTPUT"
          echo "patches-branch=$PATCHES_BRANCH" >> "$GITHUB_OUTPUT"
          echo "cli-branch=$CLI_BRANCH" >> "$GITHUB_OUTPUT"

          # Load previous state
          if [ -f state.json ] && jq empty state.json >/dev/null 2>&1; then
            PREV_PATCHES=$(jq -r '.patches_version // "none"' state.json)
            PREV_CLI=$(jq -r '.cli_version // "none"' state.json)
            PREV_PATCHES_BRANCH=$(jq -r '.patches_branch // "main"' state.json)
            PREV_CLI_BRANCH=$(jq -r '.cli_branch // "main"' state.json)
          else
            if [ -f state.json ]; then
              echo "::warning::state.json is missing or invalid JSON; using default previous state."
            fi
            PREV_PATCHES="none"
            PREV_CLI="none"
            PREV_PATCHES_BRANCH="main"
            PREV_CLI_BRANCH="main"
          fi

          # Check if versions/channels changed
          if [ "$PATCHES_TAG" != "$PREV_PATCHES" ] || \
             [ "$CLI_TAG" != "$PREV_CLI" ] || \
             [ "$PATCHES_BRANCH" != "$PREV_PATCHES_BRANCH" ] || \
             [ "$CLI_BRANCH" != "$PREV_CLI_BRANCH" ]; then
            echo "should-build=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Version/channel changes detected. Patches: $PREV_PATCHES_BRANCH/$PREV_PATCHES -> $PATCHES_BRANCH/$PATCHES_TAG, CLI: $PREV_CLI_BRANCH/$PREV_CLI -> $CLI_BRANCH/$CLI_TAG"
          else
            echo "should-build=false" >> "$GITHUB_OUTPUT"
            echo "::notice::No version/channel changes detected. Skipping build."
          fi

  build:
    needs: check-versions
    if: needs.check-versions.outputs.should-build == 'true'
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: youtube
            appId: com.google.android.youtube
          - name: ytmusic
            appId: com.google.android.apps.youtube.music
          - name: reddit
            appId: com.reddit.frontpage

    env:
      # Where we'll put tools/artifacts
      GH_TOKEN: ${{ github.token }}
      TOOLS_DIR: tools
      APKS_DIR: apps
      OUT_DIR: out
      PLAYWRIGHT_CACHE_VERSION: "1"
      PATCHES_VERSION: ${{ needs.check-versions.outputs.patches-version }}
      CLI_VERSION: ${{ needs.check-versions.outputs.cli-version }}
      PATCHES_BRANCH: ${{ needs.check-versions.outputs.patches-branch }}
      CLI_BRANCH: ${{ needs.check-versions.outputs.cli-branch }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java (for morphe-cli)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17" # any current LTS JRE is fine to run the CLI [9](https://aur.archlinux.org/packages/morphe-cli)

      - name: Set up Node.js (for Playwright downloader)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Restore npm cache (Playwright downloader)
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-playwright-npm-${{ env.PLAYWRIGHT_CACHE_VERSION }}

      - name: Install jq & Playwright downloader
        id: downloader
        run: |
          set -euo pipefail
          
          echo "::notice::Installing dependencies..."
          sudo apt-get update -y
          sudo apt-get install -y jq curl unzip libbcprov-java
          
          # Verify installation
          if ! command -v npm &> /dev/null; then
            echo "::error::npm is not available"
            exit 1
          fi

          npm install --no-save --no-package-lock playwright-core
          if [ ! -f ".github/scripts/apkmirror-playwright.js" ]; then
            echo "::error::Playwright downloader script is missing: .github/scripts/apkmirror-playwright.js"
            exit 1
          fi
          node --check .github/scripts/apkmirror-playwright.js

          PLAYWRIGHT_BROWSER_BIN="$(
            command -v google-chrome \
              || command -v google-chrome-stable \
              || command -v chromium \
              || command -v chromium-browser \
              || true
          )"
          if [ -n "$PLAYWRIGHT_BROWSER_BIN" ]; then
            echo "::notice::Detected browser for Playwright downloader: $PLAYWRIGHT_BROWSER_BIN"
          else
            echo "::warning::No browser binary detected for Playwright downloader (google-chrome/chromium)."
          fi

          echo "browser=$PLAYWRIGHT_BROWSER_BIN" >> "$GITHUB_OUTPUT"

      - name: Prepare dirs
        run: |
          mkdir -p "$TOOLS_DIR" "$APKS_DIR" "$OUT_DIR"

      - name: Get latest Morphe patches + CLI + APKEditor
        id: morphe
        run: |
          set -euo pipefail

          # Reuse versions already resolved in check-versions job.
          PATCHES_TAG="${PATCHES_VERSION}"
          CLI_TAG="${CLI_VERSION}"
          if [ -z "$PATCHES_TAG" ] || [ -z "$CLI_TAG" ]; then
            echo "::error::Missing release version(s). patches='$PATCHES_TAG' cli='$CLI_TAG'"
            exit 1
          fi
          echo "::notice::Using Morphe channels: patches=${PATCHES_BRANCH}, cli=${CLI_BRANCH}"
          echo "::notice::Resolved Morphe versions: patches=${PATCHES_TAG}, cli=${CLI_TAG}"

          echo "patches_tag=$PATCHES_TAG" >> "$GITHUB_OUTPUT"
          gh release download "$PATCHES_TAG" \
            --repo MorpheApp/morphe-patches \
            --pattern 'patches-*.mpp' \
            --dir "$TOOLS_DIR" >/dev/null
          # also fetch patches-list.json to know available patches by app [3](https://github.com/MorpheApp/morphe-patches)
          curl -fsSL "https://raw.githubusercontent.com/MorpheApp/morphe-patches/${PATCHES_TAG}/patches-list.json" \
            -o "$TOOLS_DIR/patches-list.json"

          echo "cli_tag=$CLI_TAG" >> "$GITHUB_OUTPUT"
          gh release download "$CLI_TAG" \
            --repo MorpheApp/morphe-cli \
            --pattern 'morphe-cli-*-all.jar' \
            --dir "$TOOLS_DIR" >/dev/null

          # Download APKEditor for split APK merge (.xapk/.apkm/.apks -> standalone .apk).
          APKEDITOR_TAG="$(gh release view --repo REAndroid/APKEditor --json tagName -q .tagName)"
          APKEDITOR_ASSET="$(
            gh release view "$APKEDITOR_TAG" --repo REAndroid/APKEditor --json assets \
              -q '.assets[] | select(.name | endswith(".jar")) | .name' \
              | head -n1
          )"
          if [ -z "$APKEDITOR_ASSET" ]; then
            echo "::error::Could not find APKEditor .jar asset on release ${APKEDITOR_TAG}."
            exit 1
          fi
          gh release download "$APKEDITOR_TAG" \
            --repo REAndroid/APKEditor \
            --pattern "$APKEDITOR_ASSET" \
            --dir "$TOOLS_DIR" >/dev/null

          APKEDITOR_JAR_PATH="$TOOLS_DIR/$APKEDITOR_ASSET"
          if [ ! -f "$APKEDITOR_JAR_PATH" ]; then
            echo "::error::APKEditor download failed: $APKEDITOR_JAR_PATH"
            exit 1
          fi
          echo "apkeditor_jar=$APKEDITOR_JAR_PATH" >> "$GITHUB_OUTPUT"
          echo "::notice::Downloaded APKEditor ${APKEDITOR_TAG}: ${APKEDITOR_ASSET}"

      - name: Sync patches.json with latest patches (preserve edits)
        run: |
          set -euo pipefail

          DEFAULTS_FILE="$RUNNER_TEMP/default_patches.json"
          EXISTING_FILE="$RUNNER_TEMP/existing_patches.json"
          PKGS='["com.google.android.youtube","com.google.android.apps.youtube.music","com.reddit.frontpage"]'

          # Build defaults for all known apps from the latest patches list.
          # This handles both object-style and array-style compatibility schemas.
          jq --argjson pkgs "$PKGS" '
            . as $src
            |
            def compat_pkg_names($patch):
              if ($patch.compatiblePackages? | type) == "object" then
                ($patch.compatiblePackages | keys)
              elif ($patch.compatible_packages? | type) == "object" then
                ($patch.compatible_packages | keys)
              elif ($patch.compatiblePackages? | type) == "array" then
                ($patch.compatiblePackages | map(.name // .packageName // empty))
              elif ($patch.compatible_packages? | type) == "array" then
                ($patch.compatible_packages | map(.name // .packageName // empty))
              else
                []
              end;

            reduce $pkgs[] as $pkg ({};
              .[$pkg] = (
                reduce (
                  (($src.patches // $src)[])
                  | select((compat_pkg_names(.) | index($pkg)) != null)
                  | .name
                ) as $name
                ({};
                  .[$name] = true
                )
              )
            )
          ' "$TOOLS_DIR/patches-list.json" > "$DEFAULTS_FILE"

          # Load existing user config if valid JSON, otherwise start fresh.
          if [ -f patches.json ] && jq empty patches.json >/dev/null 2>&1; then
            cp patches.json "$EXISTING_FILE"
          else
            if [ -f patches.json ]; then
              echo "::warning::Existing patches.json is invalid JSON; regenerating from defaults."
            fi
            echo '{}' > "$EXISTING_FILE"
          fi

          # Merge defaults with existing file, preserving user-edited values.
          jq -n --slurpfile defaults "$DEFAULTS_FILE" --slurpfile existing "$EXISTING_FILE" '
            ($defaults[0] // {}) as $d
            | ($existing[0] // {}) as $e
            | ($e | if type == "object" then . else {} end) as $base
            | reduce ($d | keys[]) as $pkg ($base;
                .[$pkg] = (
                  ($d[$pkg] // {})
                  * ((.[$pkg] // {}) | if type == "object" then . else {} end)
                )
              )
          ' > patches.json.tmp
          mv patches.json.tmp patches.json

          echo "::notice::Synced patches.json with latest available patches while preserving existing edits."
          jq 'keys' patches.json

      - name: Resolve supported version for ${{ matrix.appId }}
        id: targetver
        run: |
          set -euo pipefail

          DISABLED_PATCHES_JSON="$(jq -c --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries | map(select(.value == false) | .key)' patches.json)"

          STRICT_VERSIONS="$(
            jq -r \
              --arg pkg "${{ matrix.appId }}" \
              --argjson disabled "$DISABLED_PATCHES_JSON" \
              '
              (.patches // .)
              | map(
                  select(
                    ((.use // true) == true)
                    and ((.name as $n | ($disabled | index($n)) | not))
                    and ((.compatiblePackages[$pkg]? | type) == "array")
                  )
                )
              | map(.compatiblePackages[$pkg]) as $version_lists
              | if ($version_lists | length) == 0 then
                  empty
                else
                  reduce $version_lists[] as $current ($version_lists[0];
                    map(select($current | index(.)))
                  )[]
                end
              ' "$TOOLS_DIR/patches-list.json" || true
          )"

          VERSION_COUNTS="$(
            jq -r \
              --arg pkg "${{ matrix.appId }}" \
              --argjson disabled "$DISABLED_PATCHES_JSON" \
              '
              (.patches // .) as $patches
              | $patches
              | map(
                  select(
                    ((.use // true) == true)
                    and ((.name as $n | ($disabled | index($n)) | not))
                    and ((.compatiblePackages[$pkg]? | type) == "array")
                  )
                )
              | map(.compatiblePackages[$pkg][])
              | sort
              | group_by(.)
              | map([length, .[0]])
              | .[]
              | @tsv
              ' "$TOOLS_DIR/patches-list.json" || true
          )"

          TARGET_VERSION=""
          TARGET_VERSIONS=""
          if [ -n "$STRICT_VERSIONS" ]; then
            TARGET_VERSIONS="$(printf '%s\n' "$STRICT_VERSIONS" | sort -Vr | paste -sd, -)"
            TARGET_VERSION="$(printf '%s\n' "$STRICT_VERSIONS" | sort -Vr | head -n1)"
          elif [ -n "$VERSION_COUNTS" ]; then
            TARGET_VERSIONS="$(printf '%s\n' "$VERSION_COUNTS" | sort -t $'\t' -k1,1nr -k2,2Vr | cut -f2 | paste -sd, -)"
            TARGET_VERSION="$(printf '%s\n' "$VERSION_COUNTS" | sort -t $'\t' -k1,1nr -k2,2Vr | head -n1 | cut -f2)"
          fi

          if [ -n "$TARGET_VERSION" ]; then
            echo "version=$TARGET_VERSION" >> "$GITHUB_OUTPUT"
            echo "versions=$TARGET_VERSIONS" >> "$GITHUB_OUTPUT"
            echo "::notice::Selected Morphe-recommended version for ${{ matrix.appId }}: $TARGET_VERSION"
          else
            echo "version=" >> "$GITHUB_OUTPUT"
            echo "versions=" >> "$GITHUB_OUTPUT"
            echo "::error::Could not resolve a Morphe-supported version from patches list."
            exit 1
          fi

      - name: Download supported APK for ${{ matrix.appId }}
        id: getapk
        run: |
          set -euo pipefail
          
          echo "::notice::Downloading APK for ${{ matrix.appId }}..."
          APP_ID="${{ matrix.appId }}"
          TARGET_VERSION="${{ steps.targetver.outputs.version }}"
          TARGET_VERSIONS="${{ steps.targetver.outputs.versions }}"
          APKEDITOR_JAR="${{ steps.morphe.outputs.apkeditor_jar }}"
          PLAYWRIGHT_BROWSER_BIN="${{ steps.downloader.outputs.browser }}"
          
          # Create output directory if it doesn't exist
          mkdir -p "$APKS_DIR"
          rm -f "$APKS_DIR"/* || true

          # Manual source URL override (required, per app/per version).
          # patches.json shape:
          # "__morphe": {
          #   "download_urls": {
          #     "com.google.android.youtube": {
          #       "20.40.45": "https://www.apkmirror.com/apk/.../android-apk-download/",
          #       "latest_supported": "https://www.apkmirror.com/apk/.../android-apk-download/"
          #     }
          #   }
          # }
          MANUAL_URL="$(
            jq -r \
              --arg pkg "$APP_ID" \
              --arg ver "$TARGET_VERSION" \
              '
                .["__morphe"]?.download_urls?[$pkg]?[$ver]
                // .["__morphe"]?.download_urls?[$pkg]?["latest_supported"]
                // empty
              ' patches.json 2>/dev/null || true
          )"
          
          find_package_candidate() {
            find "$APKS_DIR" -type f \
              \( -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" -o -name "*.apks" \) \
              -printf '%p\n' \
              | awk '
                  function lower(s){ return tolower(s) }
                  function score(path, n, ext, s) {
                    n = lower(path)
                    ext = n
                    sub(/^.*\./, "", ext)
                    s = 0
                    if (ext == "apk") s += 2000
                    else if (ext == "xapk" || ext == "apkm" || ext == "apks") s += 500
                    if (n ~ /\/base\.apk$/) s += 500
                    if (n ~ /arm64-v8a|arm64_v8a|arm64/) s += 800
                    if (n ~ /x86_64|x86/) s -= 600
                    if (n ~ /armeabi-v7a|arm-v7a|v7a/) s -= 300
                    if (n ~ /split_config|(^|\/)config\./) s -= 1400
                    return s
                  }
                  {
                    s = score($0)
                    if (best == "" || s > bests) {
                      best = $0
                      bests = s
                    }
                  }
                  END { if (best != "") print best }
                ' || true
          }

          apk_has_dex() {
            local apk="$1"
            unzip -Z1 "$apk" 2>/dev/null | grep -Eq '^classes([0-9]+)?\.dex$'
          }

          merge_split_package_with_apkeditor() {
            local split_pkg="$1"
            local out_apk="$2"
            local merge_log="$RUNNER_TEMP/apkeditor_merge_${{ matrix.name }}.log"
            if [ -z "${APKEDITOR_JAR}" ] || [ ! -f "${APKEDITOR_JAR}" ]; then
              echo "::warning::APKEditor jar not available; cannot merge split package."
              return 1
            fi

            rm -f "$out_apk"
            echo "::notice::Merging split package with APKEditor: $split_pkg"
            set +e
            java -jar "${APKEDITOR_JAR}" m -i "$split_pkg" -o "$out_apk" >"$merge_log" 2>&1
            local rc=$?
            set -e
            if [ "$rc" -eq 0 ] && [ ! -f "$out_apk" ]; then
              # Some APKEditor versions ignore -o and emit *_merged.apk next to input.
              local default_merged="${split_pkg%.*}_merged.apk"
              local fallback_merged
              fallback_merged="$(find "$(dirname "$split_pkg")" -maxdepth 1 -type f -name "*_merged.apk" -printf '%p\n' | head -n1 || true)"
              if [ -f "$default_merged" ]; then
                mv -f "$default_merged" "$out_apk"
              elif [ -n "$fallback_merged" ] && [ -f "$fallback_merged" ]; then
                mv -f "$fallback_merged" "$out_apk"
              fi
            fi

            if [ "$rc" -ne 0 ] || [ ! -f "$out_apk" ]; then
              echo "::warning::APKEditor merge failed for $split_pkg"
              cat "$merge_log" || true
              return 1
            fi

            if ! apk_has_dex "$out_apk"; then
              echo "::warning::APKEditor output has no classes.dex: $out_apk"
              return 1
            fi
            return 0
          }

          best_ranked_apk_in_dir() {
            local dir="$1"
            find "$dir" -type f -name "*.apk" -printf '%p\n' \
              | awk '
                  function lower(s){ return tolower(s) }
                  function score(path, n, b, s) {
                    n = lower(path)
                    b = n
                    sub(/^.*\//, "", b)
                    s = 0
                    if (b == "base.apk") s += 500
                    if (n ~ /arm64-v8a|arm64_v8a|arm64/) s += 800
                    if (n ~ /x86_64|x86/) s -= 600
                    if (n ~ /armeabi-v7a|arm-v7a|v7a/) s -= 300
                    if (n ~ /split_config|(^|\/)config\./) s -= 1400
                    return s
                  }
                  { print score($0), $0 }
                ' | sort -nr | cut -d' ' -f2-
          }

          download_with_manual_url() {
            local url="$1"

            download_with_playwright() {
              local source_url="$1"
              local meta_file="$RUNNER_TEMP/apkmirror_pw_meta_${{ matrix.name }}.json"
              local bin_file="$RUNNER_TEMP/apkmirror_pw_bin_${{ matrix.name }}"
              local pw_name=""
              local pw_ext=""

              if [ -z "$PLAYWRIGHT_BROWSER_BIN" ] || [ ! -x "$PLAYWRIGHT_BROWSER_BIN" ]; then
                echo "::warning::Playwright downloader unavailable: browser binary not found."
                return 1
              fi

              rm -f "$meta_file" "$bin_file"
              if ! node .github/scripts/apkmirror-playwright.js \
                "$source_url" \
                "$PLAYWRIGHT_BROWSER_BIN" \
                "$meta_file" \
                "$bin_file"; then
                echo "::warning::Playwright download failed."
                return 1
              fi

              if [ ! -s "$bin_file" ]; then
                echo "::warning::Playwright downloader did not produce an APK payload."
                return 1
              fi

              pw_name="$(jq -r '.filename // empty' "$meta_file" 2>/dev/null || true)"
              echo "::notice::Playwright meta: $(jq -c '{via, direct_url, filename, bytes, content_type}' "$meta_file" 2>/dev/null || cat "$meta_file" || true)"
              if [ -z "$pw_name" ]; then
                pw_name="${APP_ID}.apk"
              fi

              pw_ext="${pw_name##*.}"
              case "${pw_ext,,}" in
                apk|xapk|apkm|apks) ;;
                *) pw_name="${APP_ID}.apk" ;;
              esac

              mv -f "$bin_file" "$APKS_DIR/$pw_name"
              echo "::notice::Playwright download saved: $APKS_DIR/$pw_name"
              return 0
            }

            if [ -z "$url" ]; then
              echo "::error::Manual APKMirror URL is empty."
              return 1
            fi

            echo "::notice::Using manual APK source URL for ${APP_ID}: $url"
            download_with_playwright "$url"
          }

          APK_CANDIDATE=""
          RESOLVED_DOWNLOAD_VERSION=""
          if [ -z "$TARGET_VERSION" ]; then
            echo "::error::No latest Morphe-supported version was resolved for ${{ matrix.appId }}."
            exit 1
          fi

          if [ -z "$MANUAL_URL" ]; then
            echo "::error::No manual download URL configured for ${{ matrix.appId }} ($TARGET_VERSION)."
            echo "::notice::Set patches.json -> __morphe.download_urls.${{ matrix.appId }}.${TARGET_VERSION} or latest_supported."
            exit 1
          fi

          echo "::notice::Trying manual source URL for latest Morphe-supported version $TARGET_VERSION..."
          if download_with_manual_url "$MANUAL_URL"; then
            echo "::notice::Manual source download completed for version $TARGET_VERSION"
          else
            echo "::error::Manual source download failed for version $TARGET_VERSION."
            exit 1
          fi

          APK_CANDIDATE="$(find_package_candidate)"
          if [ -n "$APK_CANDIDATE" ] && [ -f "$APK_CANDIDATE" ]; then
            RESOLVED_DOWNLOAD_VERSION="$TARGET_VERSION"
          fi

          if [ -z "$APK_CANDIDATE" ]; then
            echo "::error::No package downloaded for latest Morphe-supported version $TARGET_VERSION for ${{ matrix.appId }}."
            echo "::notice::All compatible versions (for reference): $TARGET_VERSIONS"
            exit 1
          fi

          if [ -n "$APK_CANDIDATE" ] && [ -f "$APK_CANDIDATE" ]; then
            echo "::notice::Found package in $APKS_DIR: $APK_CANDIDATE"
          else
            # Fallback: check current directory and move into APKS_DIR.
            APK_FOUND="$(find . -maxdepth 1 -type f \( -name "*${{ matrix.appId }}*.apk" -o -name "*${{ matrix.appId }}*.xapk" -o -name "*${{ matrix.appId }}*.apkm" -o -name "*${{ matrix.appId }}*.apks" -o -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" -o -name "*.apks" \) | head -n1 || true)"
            if [ -n "$APK_FOUND" ] && [ -f "$APK_FOUND" ]; then
              echo "::notice::Found package in current dir: $APK_FOUND"
              mv "$APK_FOUND" "$APKS_DIR/"
              APK_CANDIDATE="$APKS_DIR/$(basename "$APK_FOUND")"
            else
              echo "::error::No APK found after download"
              echo "::notice::Files in current directory:"
              ls -la
              echo "::notice::Files in $APKS_DIR:"
              ls -la "$APKS_DIR" || true
              exit 1
            fi
          fi

          # If an APK was selected directly, ensure it contains dex classes and is not a split-only config APK.
          if [[ "$APK_CANDIDATE" == *.apk ]] && ! apk_has_dex "$APK_CANDIDATE"; then
            echo "::warning::Selected APK does not contain classes.dex; trying another APK candidate."
            ALT_APK="$(best_ranked_apk_in_dir "$APKS_DIR")"
            while IFS= read -r candidate; do
              [ -z "$candidate" ] && continue
              if apk_has_dex "$candidate"; then
                APK_CANDIDATE="$candidate"
                echo "::notice::Using APK with dex content: $APK_CANDIDATE"
                break
              fi
            done <<< "$ALT_APK"
          fi

          # If we still have a dex-less APK candidate, prefer any split package and merge it.
          if [[ "$APK_CANDIDATE" == *.apk ]] && ! apk_has_dex "$APK_CANDIDATE"; then
            SPLIT_FOUND="$(find "$APKS_DIR" -maxdepth 1 -type f \( -name "*.xapk" -o -name "*.apkm" -o -name "*.apks" \) | head -n1 || true)"
            if [ -n "$SPLIT_FOUND" ]; then
              echo "::warning::Switching to split package for merge: $SPLIT_FOUND"
              APK_CANDIDATE="$SPLIT_FOUND"
            fi
          fi

          # If downloader produced split package (.xapk/.apkm/.apks), merge to an installable APK.
          APK_PATH="$APK_CANDIDATE"
          case "$APK_CANDIDATE" in
            *.xapk|*.apkm|*.apks)
              echo "::notice::Split package detected ($APK_CANDIDATE); attempting APKEditor merge..."
              APK_PATH="$APKS_DIR/${{ matrix.appId }}.apk"
              if merge_split_package_with_apkeditor "$APK_CANDIDATE" "$APK_PATH"; then
                echo "::notice::Merged APK created: $APK_PATH"
              else
                echo "::warning::APKEditor merge failed; falling back to direct APK extraction."
                XAPK_TMP="$RUNNER_TEMP/xapk_${{ matrix.name }}"
                rm -rf "$XAPK_TMP"
                mkdir -p "$XAPK_TMP"
                unzip -o -q "$APK_CANDIDATE" '*.apk' -d "$XAPK_TMP" || true

                # Prefer arm64-v8a APK names, but only if the APK contains dex content.
                EXTRACTED_APK=""
                while IFS= read -r candidate; do
                  [ -z "$candidate" ] && continue
                  if apk_has_dex "$candidate"; then
                    EXTRACTED_APK="$candidate"
                    break
                  fi
                done < <(best_ranked_apk_in_dir "$XAPK_TMP")
                if [ -z "$EXTRACTED_APK" ]; then
                  # Last fallback: largest dex-bearing APK in archive.
                  while IFS= read -r candidate; do
                    [ -z "$candidate" ] && continue
                    if apk_has_dex "$candidate"; then
                      EXTRACTED_APK="$candidate"
                      break
                    fi
                  done < <(find "$XAPK_TMP" -type f -name "*.apk" -printf '%s %p\n' | sort -nr | cut -d' ' -f2-)
                fi

                if [ -z "$EXTRACTED_APK" ] || [ ! -f "$EXTRACTED_APK" ]; then
                  echo "::error::Could not extract APK from split package: $APK_CANDIDATE"
                  echo "::notice::Archive APK contents:"
                  find "$XAPK_TMP" -type f -name "*.apk" -print || true
                  exit 1
                fi

                cp "$EXTRACTED_APK" "$APK_PATH"
                echo "::notice::Extracted APK: $APK_PATH (from $(basename "$EXTRACTED_APK"))"
              fi
              ;;
          esac

          if [ ! -f "$APK_PATH" ]; then
            echo "::error::APK path check failed: $APK_PATH"
            exit 1
          fi

          if ! apk_has_dex "$APK_PATH"; then
            echo "::error::Chosen APK has no classes.dex and cannot be patched: $APK_PATH"
            echo "::notice::Files in $APKS_DIR:"
            find "$APKS_DIR" -type f \( -name "*.apk" -o -name "*.xapk" -o -name "*.apkm" -o -name "*.apks" \) -print || true
            exit 1
          fi
          
          echo "apk=$APK_PATH" >> "$GITHUB_OUTPUT"
          
          # Extract version from APK filename
          APK_FILENAME=$(basename "$APK_PATH")
          APK_VERSION=$(echo "$APK_FILENAME" | grep -oE '[0-9]+(\.[0-9]+){2,}' | head -1 || true)
          if [ -z "$APK_VERSION" ] && [ -n "$RESOLVED_DOWNLOAD_VERSION" ]; then
            APK_VERSION="$RESOLVED_DOWNLOAD_VERSION"
          fi
          if [ -z "$APK_VERSION" ] && [ -n "$TARGET_VERSION" ]; then
            APK_VERSION="$TARGET_VERSION"
          fi
          if [ -z "$APK_VERSION" ]; then
            APK_VERSION="unknown"
          fi
          echo "version=$APK_VERSION" >> "$GITHUB_OUTPUT"
          echo "::notice::Downloaded ${{ matrix.name }} → $APK_PATH (v$APK_VERSION)"

      - name: Prepare signing keystore (required)
        id: keystore
        run: |
          set -euo pipefail

          KEYSTORE_B64="${{ secrets.KEYSTORE_BASE64 }}"
          KEYSTORE_PASSWORD="${{ secrets.KEYSTORE_PASSWORD }}"
          KEY_PASSWORD_RAW="${{ secrets.KEY_PASSWORD }}"
          KEY_ALIAS_INPUT="${{ secrets.KEY_ALIAS }}"

          if [ -z "$KEYSTORE_B64" ]; then
            echo "::error::KEYSTORE_BASE64 secret is required (signed builds are enforced)."
            exit 1
          fi
          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "::error::KEYSTORE_PASSWORD secret is required (signed builds are enforced)."
            exit 1
          fi
          BCPROV_JAR="$(ls -1 /usr/share/java/bcprov*.jar 2>/dev/null | head -n1 || true)"
          if [ -z "$BCPROV_JAR" ] || [ ! -f "$BCPROV_JAR" ]; then
            echo "::error::BouncyCastle provider JAR not found on runner."
            exit 1
          fi

          RAW_KEYSTORE="$TOOLS_DIR/source.keystore"
          DEST_KEYSTORE="$TOOLS_DIR/morphe.bks"
          rm -f "$RAW_KEYSTORE" "$DEST_KEYSTORE"

          echo "$KEYSTORE_B64" | base64 -d > "$RAW_KEYSTORE"

          detect_keystore_type() {
            local type="$1"
            local -a args=(keytool -list -keystore "$RAW_KEYSTORE" -storetype "$type" -storepass "$KEYSTORE_PASSWORD")
            if [ "$type" = "BKS" ] || [ "$type" = "UBER" ]; then
              args+=(-providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath "$BCPROV_JAR")
            fi
            "${args[@]}" >/dev/null 2>&1
          }

          SRC_TYPE=""
          for t in PKCS12 JKS BKS UBER; do
            if detect_keystore_type "$t"; then
              SRC_TYPE="$t"
              break
            fi
          done

          if [ -z "$SRC_TYPE" ]; then
            echo "::error::Could not detect source keystore type using PKCS12/JKS/BKS/UBER."
            exit 1
          fi
          echo "::notice::Detected source keystore type: $SRC_TYPE"

          IMPORT_LOG="$RUNNER_TEMP/keytool_import_${{ matrix.name }}.log"
          run_import() {
            local mode="$1"
            shift
            echo "::notice::Converting keystore to BKS (mode=$mode)..."
            set +e
            "$@" >"$IMPORT_LOG" 2>&1
            local rc=$?
            set -e
            if [ "$rc" -ne 0 ]; then
              echo "::warning::keytool import failed in mode=$mode"
              cat "$IMPORT_LOG" || true
            fi
            return "$rc"
          }

          IMPORT_BASE_ARGS=(
            keytool -importkeystore -noprompt
            -srckeystore "$RAW_KEYSTORE"
            -srcstoretype "$SRC_TYPE"
            -srcstorepass "$KEYSTORE_PASSWORD"
            -destkeystore "$DEST_KEYSTORE"
            -deststoretype BKS
            -deststorepass "$KEYSTORE_PASSWORD"
            -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider
            -providerpath "$BCPROV_JAR"
          )

          # Try import without explicit key password first. This works for the common case where
          # key password matches store password and avoids false failures from wrong KEY_PASSWORD.
          if ! run_import "no-keypass" "${IMPORT_BASE_ARGS[@]}"; then
            # Retry with explicit key password if provided.
            if [ -n "$KEY_PASSWORD_RAW" ]; then
              rm -f "$DEST_KEYSTORE"
              if ! run_import "explicit-keypass" "${IMPORT_BASE_ARGS[@]}" -srckeypass "$KEY_PASSWORD_RAW" -destkeypass "$KEY_PASSWORD_RAW"; then
                echo "::error::Failed to convert keystore to BKS."
                echo "::error::Check KEYSTORE_PASSWORD and KEY_PASSWORD secrets."
                exit 1
              fi
            else
              echo "::error::Failed to convert keystore to BKS."
              echo "::error::If your key password differs from KEYSTORE_PASSWORD, set KEY_PASSWORD secret."
              exit 1
            fi
          fi

          if [ ! -f "$DEST_KEYSTORE" ]; then
            echo "::error::Failed to create converted BKS keystore."
            exit 1
          fi

          list_aliases() {
            keytool -list \
              -keystore "$DEST_KEYSTORE" \
              -storetype BKS \
              -storepass "$KEYSTORE_PASSWORD" \
              -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider \
              -providerpath "$BCPROV_JAR" \
              2>/dev/null | awk -F, '/,/{print $1}' | sed '/^$/d'
          }

          mapfile -t KEY_ALIASES < <(list_aliases)
          if [ "${#KEY_ALIASES[@]}" -eq 0 ]; then
            echo "::error::No aliases found in converted keystore."
            exit 1
          fi

          KEY_ALIAS="$KEY_ALIAS_INPUT"
          if [ -z "$KEY_ALIAS" ]; then
            KEY_ALIAS="${KEY_ALIASES[0]}"
            echo "::notice::No KEY_ALIAS provided; using alias '$KEY_ALIAS'."
          else
            ALIAS_FOUND=false
            for a in "${KEY_ALIASES[@]}"; do
              if [ "$a" = "$KEY_ALIAS" ]; then
                ALIAS_FOUND=true
                break
              fi
            done
            if [ "$ALIAS_FOUND" = false ]; then
              echo "::error::KEY_ALIAS '$KEY_ALIAS' was not found in the converted keystore."
              echo "::notice::Available aliases: ${KEY_ALIASES[*]}"
              exit 1
            fi
          fi

          echo "path=$DEST_KEYSTORE" >> "$GITHUB_OUTPUT"
          echo "alias=$KEY_ALIAS" >> "$GITHUB_OUTPUT"
          echo "::notice::Prepared BKS keystore for Morphe signing."

      - name: Patch ${{ matrix.name }} with morphe-cli
        id: patch
        run: |
          set -euo pipefail
          JAR="$(ls -1 $TOOLS_DIR/morphe-cli-*-all.jar | head -n1)"
          MPP="$(ls -1 $TOOLS_DIR/patches-*.mpp | head -n1)"
          APK="${{ steps.getapk.outputs.apk }}"
          APK_VERSION="${{ steps.getapk.outputs.version }}"
          APK_NORM="${APK#./}"
          KEYSTORE_FILE="${{ steps.keystore.outputs.path }}"
          KEY_ALIAS="${{ steps.keystore.outputs.alias }}"
          KEYSTORE_PASSWORD="${{ secrets.KEYSTORE_PASSWORD }}"
          KEY_ENTRY_PASS="${{ secrets.KEY_PASSWORD }}"
          if [ -z "$KEY_ENTRY_PASS" ]; then
            KEY_ENTRY_PASS="$KEYSTORE_PASSWORD"
          fi

          # Signed builds are enforced.
          if [ -z "$KEYSTORE_FILE" ] || [ ! -f "$KEYSTORE_FILE" ]; then
            echo "::error::Prepared keystore file not found."
            exit 1
          fi
          if [ -z "$KEYSTORE_PASSWORD" ]; then
            echo "::error::KEYSTORE_PASSWORD secret is required for signing."
            exit 1
          fi
          KEY_ARGS=(--keystore="$KEYSTORE_FILE" --keystore-password="$KEYSTORE_PASSWORD" --keystore-entry-alias="$KEY_ALIAS" --keystore-entry-password="$KEY_ENTRY_PASS")

          # Build enabled/disabled lists from patches.json and pass disabled ones to morphe-cli.
          ENABLED_PATCHES="$(jq -r --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries[] | select(.value == true) | .key' patches.json || true)"
          DISABLED_PATCHES="$(jq -r --arg pkg "${{ matrix.appId }}" '.[$pkg] // {} | to_entries[] | select(.value == false) | .key' patches.json || true)"
          ENABLED_COUNT="$(printf '%s\n' "$ENABLED_PATCHES" | sed '/^$/d' | wc -l | tr -d ' ')"
          DISABLED_COUNT="$(printf '%s\n' "$DISABLED_PATCHES" | sed '/^$/d' | wc -l | tr -d ' ')"

          if [ "$ENABLED_COUNT" -gt 0 ]; then
            echo "::notice::Enabled patches for ${{ matrix.appId }} (${ENABLED_COUNT}): $(printf '%s\n' "$ENABLED_PATCHES" | sed '/^$/d' | paste -sd '; ' -)"
          else
            echo "::notice::Enabled patches for ${{ matrix.appId }}: none"
          fi

          if [ "$DISABLED_COUNT" -gt 0 ]; then
            echo "::notice::Disabled patches for ${{ matrix.appId }} (${DISABLED_COUNT}): $(printf '%s\n' "$DISABLED_PATCHES" | sed '/^$/d' | paste -sd '; ' -)"
          else
            echo "::notice::Disabled patches for ${{ matrix.appId }}: none"
          fi

          PATCH_ARGS=()
          while IFS= read -r patch_name; do
            [ -z "$patch_name" ] && continue
            PATCH_ARGS+=("-d" "$patch_name")
          done <<< "$DISABLED_PATCHES"

          # Create marker file so we can deterministically find CLI output files created in this step.
          MARKER="$RUNNER_TEMP/morphe_${{ matrix.name }}_start.marker"
          : > "$MARKER"

          PATCH_LOG="$RUNNER_TEMP/morphe_patch_${{ matrix.name }}.log"
          PATCH_TMP_DIR="$RUNNER_TEMP/morphe_${{ matrix.name }}"

          run_patch() {
            local mode="$1"
            shift
            echo "::notice::Running morphe-cli for ${{ matrix.appId }} (v$APK_VERSION, mode=$mode)..."
            set +e
            "$@" 2>&1 | tee "$PATCH_LOG"
            local rc=${PIPESTATUS[0]}
            set -e
            return "$rc"
          }

          build_patch_cmd() {
            local -a cmd=(java -jar "$JAR" patch --patches="$MPP")
            cmd+=("${KEY_ARGS[@]}")
            cmd+=(--temporary-files-path="$PATCH_TMP_DIR" --purge)
            cmd+=("${PATCH_ARGS[@]}")
            cmd+=("$APK")
            printf '%s\0' "${cmd[@]}"
          }

          mapfile -d '' -t PATCH_CMD < <(build_patch_cmd)
          if ! run_patch "signed-required" "${PATCH_CMD[@]}"; then
            if grep -q "Wrong version of key store" "$PATCH_LOG"; then
              echo "::error::Morphe could not read the provided keystore (Wrong version of key store)."
              echo "::error::Ensure KEYSTORE_BASE64 decodes to a valid keystore and KEYSTORE_PASSWORD/KEY_PASSWORD are correct."
            fi
            exit 1
          fi

          # Collect output: prefer APKs newer than marker and not equal to input APK.
          OUT_APK="$( \
            { find . -maxdepth 1 -type f -name "*.apk" -newer "$MARKER" -printf '%T@ %p\n' || true; \
              find "$APKS_DIR" -maxdepth 1 -type f -name "*.apk" -newer "$MARKER" -printf '%T@ %p\n' || true; } \
            | sort -nr \
            | cut -d' ' -f2- \
            | awk -v apk="$APK_NORM" '
                {
                  line=$0
                  sub(/^\.\//, "", line)
                  if (line != "" && line != apk && out == "") out=line
                }
                END { if (out != "") print out }
              ' \
          )"

          # Fallback: pick newest non-input APK if timestamps are not reliable.
          if [ -z "$OUT_APK" ] || [ ! -f "$OUT_APK" ]; then
            OUT_APK="$( \
              { find . -maxdepth 1 -type f -name "*.apk" -printf '%T@ %p\n' || true; \
                find "$APKS_DIR" -maxdepth 1 -type f -name "*.apk" -printf '%T@ %p\n' || true; } \
              | sort -nr \
              | cut -d' ' -f2- \
              | awk -v apk="$APK_NORM" '
                  {
                    line=$0
                    sub(/^\.\//, "", line)
                    if (line != "" && line != apk && out == "") out=line
                  }
                  END { if (out != "") print out }
                ' \
            )"
          fi
          if [ -z "$OUT_APK" ] || [ ! -f "$OUT_APK" ]; then
            echo "::error::Could not locate patched APK output"
            echo "::notice::Files in current directory:"
            ls -la
            echo "::notice::Files in $APKS_DIR:"
            ls -la "$APKS_DIR" || true
            exit 1
          fi
          
          # Rename with version info
          OUTPUT_NAME="${{ matrix.name }}-${PATCHES_VERSION}-v${APK_VERSION}.apk"
          mv "$OUT_APK" "$OUT_DIR/$OUTPUT_NAME"
          echo "output=$OUTPUT_NAME" >> "$GITHUB_OUTPUT"

      - name: Upload patched ${{ matrix.name }}
        uses: actions/upload-artifact@v4
        with:
          name: morphe-${{ matrix.name }}-${{ env.PATCHES_VERSION }}-v${{ steps.getapk.outputs.version }}
          path: out/${{ steps.patch.outputs.output }}

      - name: Publish release for ${{ matrix.name }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          APK_FILE="out/${{ steps.patch.outputs.output }}"
          APK_VERSION="${{ steps.getapk.outputs.version }}"
          LATEST_TAG="morphe-${{ matrix.name }}-latest"
          LATEST_TITLE="${LATEST_TAG} (${PATCHES_VERSION}, base ${APK_VERSION})"
          LATEST_ASSET_NAME="${{ matrix.name }}-latest.apk"

          if [ ! -f "$APK_FILE" ]; then
            echo "::error::APK file not found for release: $APK_FILE"
            exit 1
          fi

          RELEASE_NOTES_LATEST="$(cat <<EOF
          Rolling latest release for ${{ matrix.appId }}.
          Current base app version: ${APK_VERSION}
          Current patches channel: ${PATCHES_BRANCH}
          Current patches version: ${PATCHES_VERSION}
          Current CLI channel: ${CLI_BRANCH}
          Current CLI version: ${CLI_VERSION}
          EOF
          )"

          publish_release() {
            local tag="$1"
            local title="$2"
            local notes="$3"
            local asset="$4"
            if gh release view "$tag" >/dev/null 2>&1; then
              echo "::notice::Release $tag exists; updating asset and notes."
              gh release upload "$tag" "$asset" --clobber
              gh release edit "$tag" --title "$title" --notes "$notes"
            else
              echo "::notice::Creating release $tag"
              gh release create "$tag" "$asset" \
                --title "$title" \
                --notes "$notes"
            fi
          }

          cleanup_old_versioned_releases() {
            local app_name="${{ matrix.name }}"
            local keep_tag="$LATEST_TAG"
            local -a old_tags=()

            mapfile -t old_tags < <(
              gh api "repos/${{ github.repository }}/releases?per_page=100" --jq '
                .[]
                | .tag_name
              ' \
              | awk -v app="$app_name" -v keep="$keep_tag" '
                  $0 ~ ("^morphe-" app "-") && $0 != keep { print $0 }
                ' \
              || true
            )

            if [ "${#old_tags[@]}" -eq 0 ]; then
              echo "::notice::No old version-pinned releases found for $app_name."
              return 0
            fi

            for tag in "${old_tags[@]}"; do
              [ -z "$tag" ] && continue
              echo "::notice::Deleting old version-pinned release: $tag"
              gh release delete "$tag" --cleanup-tag -y || true
            done
          }

          # Stable tag for Obtainium (no regex needed), asset name is fixed and overwritten.
          publish_release \
            "$LATEST_TAG" \
            "$LATEST_TITLE" \
            "$RELEASE_NOTES_LATEST" \
            "$APK_FILE#${LATEST_ASSET_NAME}"

          # Keep only the rolling latest release for this app.
          cleanup_old_versioned_releases
          echo "::notice::Published tag: ${LATEST_TAG}"

  update-state:
    needs: [check-versions, build]
    if: needs.build.result == 'success' && needs.check-versions.outputs.should-build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Update state.json
        run: |
          set -euo pipefail

          PATCHES_TAG="${{ needs.check-versions.outputs.patches-version }}"
          PATCHES_LIST_FILE="$RUNNER_TEMP/patches-list.json"
          DEFAULTS_FILE="$RUNNER_TEMP/default_patches.json"
          EXISTING_FILE="$RUNNER_TEMP/existing_patches.json"
          PKGS='["com.google.android.youtube","com.google.android.apps.youtube.music","com.reddit.frontpage"]'

          # Keep repository patches.json in sync with latest upstream patches metadata
          # while preserving any user-edited true/false values.
          curl -fsSL "https://raw.githubusercontent.com/MorpheApp/morphe-patches/${PATCHES_TAG}/patches-list.json" \
            -o "$PATCHES_LIST_FILE"

          jq --argjson pkgs "$PKGS" '
            . as $src
            |
            def compat_pkg_names($patch):
              if ($patch.compatiblePackages? | type) == "object" then
                ($patch.compatiblePackages | keys)
              elif ($patch.compatible_packages? | type) == "object" then
                ($patch.compatible_packages | keys)
              elif ($patch.compatiblePackages? | type) == "array" then
                ($patch.compatiblePackages | map(.name // .packageName // empty))
              elif ($patch.compatible_packages? | type) == "array" then
                ($patch.compatible_packages | map(.name // .packageName // empty))
              else
                []
              end;

            reduce $pkgs[] as $pkg ({};
              .[$pkg] = (
                reduce (
                  (($src.patches // $src)[])
                  | select((compat_pkg_names(.) | index($pkg)) != null)
                  | .name
                ) as $name
                ({};
                  .[$name] = true
                )
              )
            )
          ' "$PATCHES_LIST_FILE" > "$DEFAULTS_FILE"

          if [ -f patches.json ] && jq empty patches.json >/dev/null 2>&1; then
            cp patches.json "$EXISTING_FILE"
          else
            echo '{}' > "$EXISTING_FILE"
          fi

          jq -n --slurpfile defaults "$DEFAULTS_FILE" --slurpfile existing "$EXISTING_FILE" '
            ($defaults[0] // {}) as $d
            | ($existing[0] // {}) as $e
            | ($e | if type == "object" then . else {} end) as $base
            | reduce ($d | keys[]) as $pkg ($base;
                .[$pkg] = (
                  ($d[$pkg] // {})
                  * ((.[$pkg] // {}) | if type == "object" then . else {} end)
                )
              )
          ' > patches.json.tmp && mv patches.json.tmp patches.json

          # Ensure state file is valid JSON before merge/update.
          if [ ! -f state.json ] || ! jq empty state.json >/dev/null 2>&1; then
            echo "::warning::state.json is missing or invalid JSON; recreating with defaults."
            echo '{}' > state.json
          fi

          # Update state and append build history.
          jq --arg patches "${{ needs.check-versions.outputs.patches-version }}" \
             --arg cli "${{ needs.check-versions.outputs.cli-version }}" \
             --arg patches_branch "${{ needs.check-versions.outputs.patches-branch }}" \
             --arg cli_branch "${{ needs.check-versions.outputs.cli-branch }}" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --arg run_id "${{ github.run_id }}" \
             --arg sha "${{ github.sha }}" \
             --argjson run_number "${{ github.run_number }}" \
             '. as $s
             | (
                 ((.build_history // [])
                  + [{
                      "timestamp": $timestamp,
                      "patches_version": $patches,
                      "cli_version": $cli,
                      "patches_branch": $patches_branch,
                      "cli_branch": $cli_branch,
                      "status": "success",
                      "run_id": $run_id,
                      "run_number": $run_number,
                      "commit": $sha
                  }])
                 | if length > 100 then .[-100:] else . end
               ) as $history
             | {
                 "patches_branch": $patches_branch,
                 "patches_version": $patches,
                 "cli_branch": $cli_branch,
                 "cli_version": $cli
               }
             + ($s | del(
                 .patches_branch,
                 .patches_version,
                 .cli_branch,
                 .cli_version,
                 .last_build,
                 .status,
                 .build_history
               ))
             + {
                 "last_build": $timestamp,
                 "status": "success",
                 "build_history": $history
               }' state.json > state.json.tmp && mv state.json.tmp state.json

      - name: Commit state.json and patches.json
        run: |
          set -euo pipefail
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add state.json patches.json
          git commit -m "chore: update state and patches config - patches ${{ needs.check-versions.outputs.patches-branch }}/${{ needs.check-versions.outputs.patches-version }}, cli ${{ needs.check-versions.outputs.cli-branch }}/${{ needs.check-versions.outputs.cli-version }}" || true
          git push || true
